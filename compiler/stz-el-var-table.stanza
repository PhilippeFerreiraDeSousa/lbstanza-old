defpackage stz/el-var-table :
  import core
  import collections
  import stz/el-ir
  import stz/dl-ir
  import stz/el-utils

;============================================================
;=================== Public Interface =======================
;============================================================

;Represents a table for holding information about
;all definitions. 
public deftype VarTable

;Retrieve the record with the given identifier. 
public defmulti get (e:VarTable, n:Int) -> VTRecord

;Retrieve the underlying IOTable used to translate DType
;into EType.
;[TODO] Try removing this. Is this useful?
public defmulti iotable (e:VarTable) -> IOTable

;============================================================
;================== VarTable Records ========================
;============================================================

;------------------------------------------------------------
;---------------- Overall Record Structure ------------------
;------------------------------------------------------------

;Represents a definition in the VarTable.
;- global?: true if the definition is a top-level definition.
;- n: the identifier of the definition.
;- entry: describes the type of the definition and its information.
public defstruct VTRecord :
  global?: True|False
  n: Int
  entry: FnEntry|VarEntry with: (updater => sub-entry)

;------------------------------------------------------------
;-------------------- Type-Specific Entries -----------------
;------------------------------------------------------------

;For representing entries to declared functions.
public deftype FnEntry

;A global function defined in EL IR.
;- targs: The identifiers of the type arguments.
;- a1: The input argument types.
;- r: The rest argument type if the function has a rest argument.
;  Only extern functions have a rest argument.
;- a2: The return type of the function.
;- lostanza?: true if it is a LoStanza function.
;- tail?: true if the function is tail-call optimized.
public defstruct EFnEntry <: FnEntry :
  targs: Tuple<Int>
  a1: Tuple<EType>
  r: EType|False
  a2: EType
  lostanza?: True|False
  tail?: True|False
with:
  printer => true

;A global function defined in DL IR.
;- ntargs: The number of type arguments.
;- a1: The input argument types.
;- r: The rest argument type if the function has a rest argument.
;  Only extern functions have a rest argument.
;- a2: The return type of the function.
;- lostanza?: true if it is a LoStanza function.
;- tail?: true if the function is tail-call optimized.
public defstruct DFnEntry <: FnEntry :
  ntargs: Int
  a1: Tuple<DType>
  r: DType|False
  a2: DType
  lostanza?: True|False
  tail?: True|False
with:
  printer => true

;Represents a multi-arity function.
;Since these functions are only used in a local-scope,
;they are always expressed in EL IR. 
public defstruct EMultifnEntry <: FnEntry :
  funcs: Tuple<EFnEntry>
with:
  printer => true

;Represents a declared variable, either local or global.
;- mutable?: true if the variable is mutable.
;- type: the declared type of the variable.
;- lostanza?: true if it is a LoStanza variable.
public defstruct VarEntry :
  mutable?: True|False
  type: EType|DType
  lostanza?: True|False
with:
  printer => true

;============================================================
;==================== VarTable Helper  ======================
;============================================================

;Private helper for creating a VarTable from the given records.
;- records: The records in the table.
;- iotable: The IOTable to use for translation.
;- parent: Inherit records from this table.
defn VarTable (records:Seqable<VTRecord>,
               iotable:IOTable,
               parent:VarTable|False) -> VarTable :
  ;Ensure that vars use etype
  val records* = seq(ensure-vars-use-etype{_, iotable}, records)
  
  ;Initialize table of records
  val table = to-inttable<VTRecord> $
    for r in records* seq :
      n(r) => r

  ;Construct VarTable      
  new VarTable :
    ;Retrieve from amongst the given records, and
    ;if it doesn't exist, then try looking in the parent table.
    defmethod get (this, n:Int) :
      match(get?(table, n), parent) :
        (r:VTRecord, p) : r
        (r:False, p:VarTable) : p[n]
        (r:False, p:False) : fatal("No entry for %_" % [n])
    ;Retrieve the wrapped IOTable.    
    defmethod iotable (this) :
      iotable

;If the given VTRecord is a VarEntry expressed with a DType,
;then re-express it using an EType.
defn ensure-vars-use-etype (r:VTRecord, iotable:IOTable) -> VTRecord :
  defn convert (e:VarEntry) -> VarEntry :
    val dt = type(e) as DType
    val et = to-etype(iotable, dt, [])
    VarEntry(mutable?(e), et, lostanza?(e))
    
  match(entry(r)) :
    (e:VarEntry) :
      match(type(e)) :
        (t:DType) : sub-entry(r, convert(e))
        (t:EType) : r
    (e) : r   

;============================================================
;================== Convenience Functions ===================
;============================================================

;Return true if the given identifier corresponds to a function
;(as opposed to a variable).
public defn function? (vt:VarTable, n:Int) -> True|False :
  entry(vt[n]) is FnEntry

;Return true if the given identifier corresponds to a variable
;(as opposed to a function).
public defn variable? (vt:VarTable, n:Int) -> True|False :
  entry(vt[n]) is VarEntry

;Return true if the function 'n' when called with 'arity' arguments
;is tail-call optimized.
;[TODO] enforce arity.
public defn tail? (vt:VarTable, n:Int, arity:Int) -> True|False :
  defn tail? (e:FnEntry) :
    match(e) :
      (e:EFnEntry) : /tail?(e)
      (e:DFnEntry) : /tail?(e)
      (e:EMultifnEntry) :
        tail?(find!({length(a1(_)) == arity}, funcs(e)))
  tail?(entry(vt[n]) as FnEntry)

;Return true if the given definition (either function or variable)
;is a LoStanza definition.
public defn lostanza? (vt:VarTable, n:Int) -> True|False :
  match(entry(vt[n])) :
    (e:EFnEntry) : lostanza?(e)
    (e:DFnEntry) : lostanza?(e)
    (e:VarEntry) : lostanza?(e)
    (e:EMultifnEntry) : false

;Return true if the given definition is a global definition (
;as opposed to a local definition.)
public defn global? (vt:VarTable, n:Int) -> True|False :
  global?(vt[n])

;Return true if the given definition corresponds to a mutable
;variable.
public defn mutable? (vt:VarTable, n:Int) -> True|False :
  match(entry(vt[n])) :
    (e:VarEntry) : mutable?(e)
    (e:FnEntry) : false

;Return all the possible arities for the function with 
;the given identifier.
;Assumes 'n' is a function definition.
;Fails if the function has a rest argument, and therefore
;doesn't have a set arity.
public defn arities (vt:VarTable, n:Int) -> Tuple<Int> :
  defn ensure-set-arity! (r:EType|False) :
    fatal("No set arity!") when r is EType
  match(entry(vt[n])) :
    (e:DFnEntry) :
      ensure-set-arity!(r(e))
      [length(a1(e))]
    (e:EFnEntry) :
      ensure-set-arity!(r(e))
      [length(a1(e))]
    (e:EMultifnEntry) :
      map(length{a1(_)}, funcs(e))

;============================================================
;================== Type Query Functions ====================
;============================================================

;Return the EType corresponding to an immediate.
public defn type (vt:VarTable, e:EImm) -> EType :
  match(e) :
    (e:ELSLiteral) :
      match(value(e)) :
        (v:Byte) : EByte()
        (v:Char) : EByte()
        (v:Int) : EInt()
        (v:Long) : ELong()
        (v:Float) : EFloat()
        (v:Double) : EDouble()
        (v:True) : EOf(n(iotable(vt), CORE-TRUE-ID))
        (v:False) : EOf(n(iotable(vt), CORE-FALSE-ID))
        (v:String) : EPtrT()
    (e:ELiteral) :
      match(value(e)) :
        (v:Byte) : EOf(n(iotable(vt), CORE-BYTE-ID))
        (v:Char) : EOf(n(iotable(vt), CORE-CHAR-ID))
        (v:Int) : EOf(n(iotable(vt), CORE-INT-ID))
        (v:Long) : EOf(n(iotable(vt), CORE-LONG-ID))
        (v:Float) : EOf(n(iotable(vt), CORE-FLOAT-ID))
        (v:Double) : EOf(n(iotable(vt), CORE-DOUBLE-ID))
        (v:True) : EOf(n(iotable(vt), CORE-TRUE-ID))
        (v:False) : EOf(n(iotable(vt), CORE-FALSE-ID))
        (v:List) : EOf(n(iotable(vt), CORE-LIST-ID))
        (v:String) : EOf(n(iotable(vt), CORE-STRING-ID))
        (v:Symbol) : EOf(n(iotable(vt), CORE-SYMBOL-ID))
    (e:EVar) : type(vt,n(e))
    (e:ESizeof) : ELong()
    (e:ETagof) : ELong()

;Return the EType corresponding to a definition.
;[TODO] Make it clear that functions are returned using HiStanza conventions.
;Q: What happens if the function cannot be a HiStanza type?
public defn type (vt:VarTable, n:Int) -> EType :
  match(entry(vt[n])) :
    (e:VarEntry) :
      ;Assumes that VarEntry is already converted to use EType.
      type(e) as EType 
    (e:FnEntry) :
      EOf(/n(iotable(vt), CORE-FN-ID))

;Retrieve the argument and return types if the immediate is called with the given arity.
;- f: the function immediate to call.
;- arity: the number of arguments to call it with.
public defn fn-types (vt:VarTable, f:EVar|ECurry, arity:Int) :
  val [n, targs] = value! $ deconstruct-function(f)
  fn-types(vt, n, arity, targs)

;Retrieve the argument and return types for the given function call.
;- n: the identifier of the function definition.
;- arity: the number of arguments to call it with.
;- targs: the type arguments to call it with.
;Returns [a1, a2]
;- a1: the argument types of the function.
;- a2: the return type of the function.
public defn fn-types (vt:VarTable, n:Int, arity:Int, targs:Tuple<EType>) -> [Tuple<EType>, EType] :
  ;Extend with rest type indefinitely
  defn ex<?T> (xs:Tuple<?T>, y:?T|False) -> Seqable<T> :
    match(y:False) : xs
    else : cat(xs, repeat(y as T))

  ;Conversion to etype
  defn to-etype (t:DType) -> EType :
    /to-etype(iotable(vt), t, targs)    

  ;Retrieve the types if n corresponds to the given function entry.
  defn retrieve-types (e:DFnEntry|EFnEntry) -> [Tuple<EType>, EType] :
    match(e) :
      (e:DFnEntry) :
        fatal("Incorrect type arity.") when ntargs(e) != length(targs)
        val a1* = to-tuple $ take-n{arity, _} $
          seq(to-etype, ex(a1(e), r(e)))
        val a2* = to-etype(a2(e))
        [a1*, a2*]
      (e:EFnEntry) :
        fatal("Incorrect type arity.") when length(/targs(e)) != length(targs)
        val tvar-table = to-inttable<EType>(/targs(e), targs)
        val a1* = to-tuple $ take-n{arity, _} $
          seq(sub-tvars{_, tvar-table}, ex(a1(e), r(e)))
        val a2* = sub-tvars(a2(e), tvar-table)
        [a1*, a2*]

  ;Launch!
  match(entry(vt[n])) :
    ;For single-arity functions, just retrieve its type directly.
    (e:DFnEntry|EFnEntry) :
      retrieve-types(e)
    ;For multi-arity functions, find the appropriate arity.
    (e:EMultifnEntry) :
      val e = find!({length(a1(_)) == arity}, funcs(e))
      retrieve-types(e)

;============================================================
;====================== Scratch =============================
;============================================================










defn GlobalVarTable (epackage:EPackage, iotable:IOTable) -> VarTable :
  ;Find records
  val imported-records = for import in imports(packageio(epackage)) seq? :
    val e = match(rec(import)) :
      (r:FnRec|MultiRec|ExternFnRec) :
        val id = id(r) as FnId
        val [lostanza?, tail?] =
          match(r) :
            (r:FnRec) : [lostanza?(r), tail?(r)]
            (r:MultiRec) : [false, false]
            (r:ExternFnRec) : [true, false]
        DFnEntry(ntargs(id) + ncargs(id), a1(id), false, a2(r), lostanza?, tail?)
      (r:ValRec) :
        VarEntry(mutable?(r), type(r), lostanza?(r))
      (r:ExternRec) :
        match(type(r)) :
          (t:DFnT) : DFnEntry(0, a(t), /r(t), b(t), true, false)
          (t) : VarEntry(true, type(r), true)
      (r) : false
    match(e:FnEntry|VarEntry) : One(VTRecord(true, n(import), e))
    else : None()
  val exported-records = for exp in exps(epackage) seq? :
    val [n, e] = match(exp) :
      (e:EDefn) : [n(e) FnEntry(func(e), lostanza?(e))]
      (e:EDefmethod) : [n(e), FnEntry(func(e), lostanza?(e))]
      (e:EDefmulti) : [n(e), EFnEntry(targs(e), a1(e), false, a2(e), false, false)]
      (e:EExternFn) : [n(e), FnEntry(func(e), true)]
      (e:EDefGlobal) : [n(e), VarEntry(mutable?(e), type(e), lostanza?(e))]
      (e:EExtern) :
        match(type(e)) :
          (t:EFnT) : [n(e), EFnEntry([], a(t), r(t), b(t), true, false)]
          (t) : [n(e), VarEntry(true, type(e), true)]
      (e) : [0, false]
    match(e:FnEntry|VarEntry) : One(VTRecord(true, n, e))
    else : None()

  ;Return populated vartable
  VarTable(cat(imported-records, exported-records), iotable, false)

defn LocalVarTable (gvt:VarTable, e:ETExp) -> VarTable :
  ;Find records
  val records = generate<VTRecord> :
    defn found (n:Int, e:FnEntry|VarEntry) :
      yield(VTRecord(false, n, e))
    ;Determine whether we are in a LoStanza context
    val lostanza-context? = match(e) :
      (e:EDefn) : lostanza?(e)
      (e:EDefClosure) : false
      (e:EDefmethod) : lostanza?(e)
      (e:EExternFn) : true
      (e:EInit) : lostanza?(e)
      (e:EDefObject) : false
      (e) : false
    let loop (e:ELBigItem = e) :
      match(e) :
        (e:EFn) :
          for (x in args(e), t in a1(e)) do :
            found(x, VarEntry(false, t, lostanza-context?))
        (e:EBody) :
          for e in localfns(e) do :
            found(n(e), FnEntry(func(e), lostanza-context?))
          for e in locals(e) do :
            found(n(e), VarEntry(mutable?(e), type(e), lostanza-context?))
        (e) : false
      do*(loop, e)

  ;Return populated table
  VarTable(records, iotable(gvt), gvt)

defn FnEntry (e:EFunction, lostanza?:True|False) :
  match(e) :
    (e:EFn) : EFnEntry(targs(e), a1(e), false, a2(e), lostanza?, tail?(e))
    (e:EMultifn) : EMultifnEntry(map({FnEntry(_, lostanza?) as EFnEntry}, funcs(e)))

;Substitute tvars for types
defn sub-tvars (t:EType, table:IntTable<EType>) :
  let loop (t:EType = t) :
    match(t:ETVar) : get?(table, n(t), t)
    else : map(loop, t)

