defpackage stz/proj-post-checks :
  import core
  import collections
  import stz/proj
  import stz/proj-ir
  import stz/proj-stage0
  import stz/proj-errors
  import stz/proj-field-types
  import stz/proj-value-types

;This pass ensures that all the post-normalized values
;are appropriate in the given file.

public defn post-normalization-checks (f:ProjFileS0, env:ProjEnv) -> ProjFileS0 :
  val errors = Vector<ProjFileError>()
  val checker = Checker(env, errors)
  defn scan (stmt:ProjStmt) :
    match(stmt:IncludedStmtsS0) :
      do(scan, stmts(stmt))
    else :     
      check-types(stmt, checker)
  do(scan, stmts(f))
  throw-proj-file-errors?(errors)
  f

;============================================================
;================ Check Individual Statement ================
;============================================================

;Create a checker for use in calling check-types.
defn Checker (env:ProjEnv,
              errors:Vector<ProjFileError>) -> Checker :
  ;Create the param type table.
  ;Each entry, [manager, field] => type, indicates that the param
  ;called 'field' for the package manager 'manager' is expected
  ;to have type 'type'.
  val param-type-table = HashTable<[Symbol,Symbol],ValueType>()
  for info in foreign-package-managers(env) do :
    for param in params(info) do :
      param-type-table[[name(info), field-name(param)]] = field-type(param)

  new Checker :
    defmethod field-type (this, manager:Symbol, field:Symbol) -> ValueType :
      param-type-table[[manager, field]]
    defmethod check (this, v:ProjValue, t:ValueType) -> False :
      match(v) :
        (v:ProjValues) :
          if single?(t) :
            val msg = "Expected %_ here." % [description(t)]
            add(errors, ProjFileError(info(v), to-string(msg)))
          else :
            for v in values(v) do :
              check(this, v, t)
        (v:CommandString) :
          check(this, value(v), t)
        (v:FilePath) :
          check(this, value(v), t)
        (v:AtomValue) :
          if not typeof?(v, atom-type(t)) :
            val msg = "Expected %_ here." % [description(t)]
            add(errors, ProjFileError(info(v), to-string(msg)))  

;Return true if the given atomic value is an instance
;of the given type.
defn typeof? (v:AtomValue, t:AtomType) -> True|False :
  switch(t) :
    StringType :
      value(v) is String
    SymbolType :
      value(v) is Symbol
    StanzaInputType :
      match(value(v)) :
        (value:String) : any?(suffix?{value, _}, [".stanza" ".pkg" ".fpkg"])
        (value:Symbol) : true

;Returns a human-readable description of the type.
;If single? is true, should return something like: "a single string".
;If single? is false, should return something like: "a string".
;Used to generate sentences like: "Expected a single string here."
defn description (t:ValueType) -> String :
  val atom-description = switch(atom-type(t)) :
    StringType: "string"
    SymbolType: "symbol"
    StanzaInputType: "Stanza file or package"
  if single?(t) : to-string("a single %_" % [atom-description])
  else : to-string("a %_" % [atom-description])