defpackage stz/packed-class-table :
  import core
  import collections
  import stz/stable-arrays

;============================================================
;============== Representation of a Record ==================
;============================================================

public deftype ClassTableRecord
public defmulti index (r:ClassTableRecord) -> Int
public defmulti name (r:ClassTableRecord) -> String

public defstruct LeafClassRecord <: ClassTableRecord :
  index:Int with: (as-method => true)
  name:String with: (as-method => true)
  size: Int
  roots: Tuple<Int>
with:
  printer => true

public defstruct ArrayClassRecord <: ClassTableRecord :
  index:Int with: (as-method => true)
  name:String with: (as-method => true)
  base-size: Int
  item-size: Int
  base-roots: Tuple<Int>
  item-roots: Tuple<Int>
with:
  printer => true

;============================================================
;====================== Static Packer =======================
;============================================================

public deftype StaticPacker <: Packer
public defmulti make-label (p:StaticPacker) -> Int
public defmulti emit-comment (p:StaticPacker, str:String) -> False
public defmulti emit-label (p:StaticPacker, id:Int) -> False
public defmulti emit-pointer-to-label (p:StaticPacker, id:Int) -> False
public defmulti emit (p:StaticPacker, x:Int) -> False
public defmulti emit (p:StaticPacker, x:String) -> False

;============================================================
;================== Overall Static Packer ===================
;============================================================

public defn pack (records:Collection<ClassTableRecord>, packer:StaticPacker) -> False :
  ;Generate labels
  val labels = to-tuple(seq(make-label{packer}, records))
  ;Emit dense labels
  do(emit-pointer-to-label{packer, _}, labels)
  ;Emit records
  for (r in records, i in 0 to false) do :
    ;Sanity check.
    if index(r) != i :
      fatal("Class %_ is supposed to be at index %_, but is actually at index %_." % [
            name(r), index(r), i])
    ;Emit comment and pack!
    emit-comment(packer, to-string("Class %_ (index %_)" % [name(r), index(r)]))
    emit-label(packer, labels[i])
    pack(r, packer)

defmethod pack (p:StaticPacker, x:Int) : emit(p, x)
defmethod pack (p:StaticPacker, s:String) : emit(p, s)

;============================================================
;================= Overall Dynamic Packer ===================
;============================================================

;Pack the given records into the given class table.
public defn pack (records:Collection<ClassTableRecord>, class-table:StableLongArray) -> False :
  ;Delete all the existing records.
  for r in records do :
    val i = index(r)
    if i < length(class-table) :
      if class-table[i] != 0L :
        delete-entry(class-table, i)

  ;Enlarge the table if necessary.
  val size-required = maximum(0, seq({index(_) + 1}, records))
  if length(class-table) < size-required :
    enlarge(class-table, size-required, 0L)

  ;Pack and store the records
  for r in records do :
    val i = index(r)
    pack-and-store(class-table, i, pack(r))

;Call free on the entry at index i in the given table.
;Set the entry to null.
lostanza defn delete-entry (table:ref<StableLongArray>, index:ref<Int>) -> ref<False> :
  val i = index.value
  val p = table.data[i] as ptr<?>
  call-c clib/free(p)
  table.data[i] = 0L
  return false      

;Pack the given record into bytes, and then store the entry
;at the given index in the table. Assumes that the slot currently contains null.
lostanza defn pack-and-store (table:ref<StableLongArray>, index:ref<Int>, record:ref<PackedClassRecord>) -> ref<False> :
  val i = index.value
  val p = pack(record)
  table.data[i] = p as long
  return false

;============================================================
;==================== Internal Packer =======================
;============================================================

deftype Packer
defmulti pack (p:Packer, x:Int) -> False
defmulti pack (p:Packer, s:String) -> False

;============================================================
;=================== Packing with Packer  ===================
;============================================================

;Leaf Class Definition:
;  num-bytes:Int, size:Int, item-size:Int (0), num-roots:Int,
;  roots:Int ..., name:String
;Array Class Definition:
;  num-bytes:Int, base-size:Int, item-size:Int, num-base-roots:Int, num-item-roots:Int,
;  base-roots:Int ..., item-roots:Int ..., name:String
defn pack (r:ClassTableRecord, packer:Packer) -> False :
  defn pack (x:Int) : /pack(packer, x)
  defn pack (x:String) : /pack(packer, x)
  match(r) :
    (r:LeafClassRecord) :
      val num-ints = 1                ;num-bytes
                   + 1                ;size
                   + 1                ;0
                   + 1                ;length(roots)
                   + length(roots(r)) ;roots
      pack(num-ints * 4)
      pack(size(r))
      pack(0)
      pack(length(roots(r)))
      do(pack, roots(r))
      pack(name(r))
    (r:ArrayClassRecord) :
      val num-ints = 1                     ;num-bytes
                   + 1                     ;base-size
                   + 1                     ;item-size
                   + 1                     ;length(base-roots)
                   + 1                     ;length(item-roots)
                   + length(base-roots(r)) ;base-roots
                   + length(item-roots(r)) ;item-roots
      pack(num-ints * 4)
      pack(base-size(r))
      pack(item-size(r))
      pack(length(base-roots(r)))
      pack(length(item-roots(r)))
      do(pack, base-roots(r))
      do(pack, item-roots(r))
      pack(name(r))

;============================================================
;=================== Pack into Record =======================
;============================================================

defstruct PackedClassRecord :
  ints:Tuple<Int>
  name:String

defn pack (r:ClassTableRecord) -> PackedClassRecord :
  val ints = Vector<Int>()
  var name:String|False = false
  val packer = new Packer :
    defmethod pack (this, x:Int) :
      add(ints, x)
    defmethod pack (this, s:String) :
      fatal("Expected only one string.") when name is String
      name = s
  pack(r, packer)
  PackedClassRecord(to-tuple(ints), name as String)
  
;============================================================
;=================== Pack into Bits =========================
;============================================================

defn num-bytes (r:PackedClassRecord) -> Int :
  length(ints(r)) * 4 + length(name(r)) + 1

lostanza defn pack (r:ref<PackedClassRecord>) -> ptr<?> :
  ;Malloc the correct number of bytes
  val num-bytes = num-bytes(r).value
  var p:ptr<?> = call-c clib/malloc(num-bytes)
  
  ;Store ints
  val ints = ints(r)
  for (var i:long = 0, i < ints.length, i = i + 1) :
    [p as ptr<int>] = ints.items[i].value
    p = p + sizeof(int)

  ;Store bytes
  val name = name(r)
  for (var i:long = 0, i < name.length, i = i + 1) :
    [p as ptr<byte>] = name.chars[i]
    p = p + sizeof(byte)

  ;Return the allocated memory.
  return p

