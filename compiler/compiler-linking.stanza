defpackage stz/compiler-linking :
  import core
  import collections
  import stz/compiler-build-settings
  import stz/compiler-result
  import stz/proj-ir
  import stz/aux-file
  import stz/system-dependencies
  import stz/external-dependencies
  import stz/linking-errors
  import stz/utils

;<doc>=======================================================
;================ High-Level Algorithm ======================
;============================================================

Linking the executable:

1) We have the list of Stanza packages that make up the program.
   Determine the final set of ccfiles and ccflags that those
   packages depend upon.

   Save these dependencies to a file if requested by
   the user.

2) Given the set of ccfiles and ccflags, compute the
   shell commands we need to execute to produce these
   files.

3) Execute the computed shell commands. If any of them fail,
   then linking is unsuccessful.

4) Finally, call the final system compiler to link the
   generated assembly file to form the executable. Pass
   it the necessary files and flags.

Cleanup:

5) Update the aux file with information about all the successful
   build commands so that we don't have to run them again later.

;============================================================
;=======================================================<doc>

;============================================================
;======================= API ================================
;============================================================

;- build-settings: The build settings that were in effect
;  during compilation.
;- compiler-result: The result of the compilation.
;- proj: The final proj file in effect during compilation.
public defstruct LinkerInput :
  build-settings:BuildSettings
  compiler-result:CompilationResult
  proj:ProjFile
  auxfile:AuxFile

;The set of callbacks for performing the necessary actions.
public defstruct LinkerEnv

;Report to the caller that an error has occurred.
public defmulti issue-error (e:LinkerEnv, err:LinkingError) -> False


;============================================================
;=================== Main Driver ============================
;============================================================

public defn link (input:LinkerInput, env:LinkerEnv) -> False :
  ;Preconditions
  ensure-ready-for-compilation!(build-settings(input))

  ;Begin
  println("Main Compiler Linking")

  val deps = compute-dependencies(
               compiler-result(input)
               proj(input)
               build-settings(input))
  println(deps)

  val commands = compute-build-commands(deps, proj(input), env)
  println(commands)


;============================================================
;================ Compute Dependencies ======================
;============================================================

;Compute the set of all external dependencies required
;by the program.
defn compute-dependencies (result:CompilationResult,
                           proj:ProjFile,
                           settings:BuildSettings) -> ProjDependencies :

  defn proj-file-dependencies () -> Seqable<ProjDependencies> :
    ;The requires statements tells us what dependencies each
    ;package has.
    val requires-table = to-hashtable(package,
      filter-by<RequiresStmt>(stmts(proj)))
    
    ;Gather both the compiled and binding packages.
    val all-packages = unique-join(compiled-packages(result),
                                   binding-packages(result))
    val package-dependencies =                                
      for package in all-packages seq :
        val requires = get?(requires-table, package)
        match(requires:RequiresStmt) :
          ProjDependencies(ccfiles(requires), ccflags(requires))
    filter-by<ProjDependencies>(package-dependencies)

  defn explicit-dependencies () -> ProjDependencies :
    ProjDependencies(
      ccfiles(settings)
      ccflags(settings))
    
  ;Launch!
  val all-dependencies = cat([system-dependencies(platform(settings) as Symbol)
                              explicit-dependencies()]
                             proj-file-dependencies())
  merge(all-dependencies)
      
;Helper: Unique join.
defn unique-join<?T> (xs:Tuple<?T>, ys:Tuple<?T>) -> Tuple<T> :
  val visited = HashSet<?>()
  to-tuple $ for v in cat(xs,ys) filter :
    add(visited,v)

;============================================================      
;================ Compute Shell Commands ====================
;============================================================      

;Returns the tuple of compilation statements that must be
;executed.
defn compute-build-commands (deps:ProjDependencies,
                             proj:ProjFile,
                             env:LinkerEnv) -> BuildCommands :
  val compile-table = to-hashtable(name,
    filter-by<CompileStmt>(stmts(proj)))

  val stmts = Vector<CompileStmt>()
  var error?: True|False = false

  ;Encountered a new error.
  defn encountered-error (e:LinkingError) :
    issue-error(env, e)
    error? = true

  ;Collect all compilation statements from files.
  for file in ccfiles(deps) do :
    val stmt = get?(compile-table,file)
    match(stmt:CompileStmt) :
      if not file?(stmt) : encountered-error(MismatchedCompilationStmt(true, file))
      else : add(stmts, stmt)
      
  ;Collect all compilation statements from flags.
  for flag in ccflags(deps) do :
    val stmt = get?(compile-table,flag)
    match(stmt:CompileStmt) :
      if file?(stmt) : encountered-error(MismatchedCompilationStmt(false, flag))
      else : add(stmts, stmt)

  ;Return collected statements.
  BuildCommands(to-tuple(stmts), error?)

;Wrap up the build commands and whether an error was encountered.
defstruct BuildCommands :
  stmts:Tuple<CompileStmt>
  errors?:True|False
with:
  printer => true