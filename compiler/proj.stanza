defpackage stz/proj :
  import core
  import collections
  import reader
  import stz/params
  import stz/utils
  import core/parsed-path
  import stz/timing-log-api
  import stz/proj-env
  import stz/proj-errors
  import stz/proj-ir
  import stz/proj-reader
  import stz/proj-stage0
  import stz/proj-wellformedness
  import stz/proj-traverse-includes
  import stz/proj-variable-substitution
  import stz/proj-normalization
  import stz/proj-post-checks
  import stz/proj-flattening
  import stz/proj-conversion
  import stz/proj-value-types

;============================================================
;======================= Timers =============================
;============================================================

val READ-PROJ-FILES = TimerLabel("Read Proj Files")
val NORMALIZE = TimerLabel(READ-PROJ-FILES, suffix("Normalize"))
val VARIABLE-SUBSTITUTION = TimerLabel(READ-PROJ-FILES, suffix("Variable Substitution"))

;============================================================
;======================== Driver ============================
;============================================================

public defn read-proj-files (filenames:Seqable<String>,
                             platform:Symbol,
                             env:ProjEnv) -> ProjFile :
  ;Return a new function that performs the same thing as stage,
  ;except that it is timed and attributed towards 'tlabel'.
  defn time<T,?S> (tlabel:TimerLabel, stage:T -> ?S) :
    fn (x:T) -> S :
      within log-time(tlabel) :
        stage(x)

  ;Helper: Read a projfile and ensure it is wellformed.
  val wellformedness = ProjWellformedness(platform, env)
  defn read-wellformed-file (filename:String) -> ProjFileS0 :
    filename $> time<String>(READ-PROJ-FILES, read-raw-proj-file)
             $> check{wellformedness, _}

  ;Helper: Read and process a file.
  defn process-file (filename:String) -> ProjFileS0 :
    filename $> read-wellformed-file
             $> traverse-includes{_, read-wellformed-file}
             $> time<ProjFileS0>(VARIABLE-SUBSTITUTION, variable-substitution)
             $> time<ProjFileS0>(NORMALIZE, normalize{_, platform})
             $> post-normalization-checks{_, env}
             $> flatten-relative-paths

  ;Process all files
  filenames
    $> seq{process-file, _}
    $> to-tuple
    $> combine
    $> convert-proj

;============================================================
;===== All Project Files by Default During Compilation ======
;============================================================

public defn default-proj-files () -> Vector<String> :
  val files = Vector<String>()
  add(files, string-join $ [STANZA-INSTALL-DIR, "/stanza.proj"])
  add-all(files, STANZA-PROJ-FILES)
  add(files, "stanza.proj") when file-exists?("stanza.proj")
  files

;============================================================
;================ Retrieve a Build Target ===================
;============================================================

public defn build-target (proj:ProjFile, target:Symbol) -> BuildStmt|False :
  for s in filter-by<BuildStmt>(stmts(proj)) find :
    name(s) == target

public defn build-target! (proj:ProjFile, target:Symbol) -> BuildStmt :
  val s = build-target(proj, target)
  match(s:BuildStmt) : s
  else : throw(ProjFileError(false, to-string("No build target named %~." % [target])))

;============================================================
;=================== Combine Files ==========================
;============================================================
defn combine (fs:Tuple<ProjFileS0>) -> ProjFileS0 :
  ;Get all statements in a vector.
  val all-stmts = to-vector<ProjStmt>(seq-cat(stmts, fs))

  ;Remove duplicate statements.
  reverse!(all-stmts)
  val visited-set = HashSet<?>()
  for stmt in all-stmts remove-when :
    val key = duplication-key(stmt)
    if key is False : false
    else : not add(visited-set, key)
  reverse!(all-stmts)

  ;Return combined project file.
  sub-stmts(fs[0], to-tuple(all-stmts))