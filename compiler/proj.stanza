defpackage stz/proj :
  import core
  import collections
  import reader
  import stz/params
  import stz/utils
  import core/parsed-path
  import stz/timing-log-api
  import stz/proj-errors
  import stz/proj-ir
  import stz/proj-reader
  import stz/proj-stage0
  import stz/proj-wellformedness
  import stz/proj-traverse-includes

;============================================================
;======================= Timers =============================
;============================================================

val READ-PROJ-FILES = TimerLabel("Read Proj Files")
val FLATTEN-RELATIVE-PATHS = TimerLabel(READ-PROJ-FILES, suffix("Flatten Relative Paths"))
val NORMALIZE = TimerLabel(READ-PROJ-FILES, suffix("Normalize"))
val VARIABLE-SUBSTITUTION = TimerLabel(READ-PROJ-FILES, suffix("Variable Substitution"))
val TRAVERSE-INCLUDES = TimerLabel(READ-PROJ-FILES, suffix("Traverse Includes"))
val ENSURE-WELLFORMED = TimerLabel(READ-PROJ-FILES, suffix("Ensure Wellformed"))

;============================================================
;======================== Driver ============================
;============================================================

public defn read-proj-files (filenames:Seqable<String>, platform:Symbol) -> ProjFile :
  ;Return a new function that performs the same thing as stage,
  ;except that it is timed and attributed towards 'tlabel'.
  defn time<T,?S> (tlabel:TimerLabel, stage:T -> ?S) :
    fn (x:T) -> S :
      within log-time(tlabel) :
        stage(x)

  ;Helper: Read a projfile and ensure it is wellformed.
  defn read-wellformed-file (filename:String) -> ProjFileS0 :
    filename $> read-raw-proj-file
             $> ensure-wellformed{_, platform}
        
  combine $ for filename in filenames seq :
    filename $> read-wellformed-file
             $> traverse-includes{_, read-wellformed-file}
             $> time<ProjFileS0>(VARIABLE-SUBSTITUTION, variable-substitution)
             $> time<ProjFileS0>(NORMALIZE, normalize{_, platform})
             $> time<ProjFileS0>(FLATTEN-RELATIVE-PATHS, flatten-relative-paths)

;============================================================
;===== All Project Files by Default During Compilation ======
;============================================================

public defn default-proj-files () -> Vector<String> :
  val files = Vector<String>()
  add(files, string-join $ [STANZA-INSTALL-DIR, "/stanza.proj"])
  add-all(files, STANZA-PROJ-FILES)
  add(files, "stanza.proj") when file-exists?("stanza.proj")
  files

;============================================================
;================ Retrieve a Build Target ===================
;============================================================

public defn build-target (proj:ProjFile, target:Symbol) -> BuildStmt|False :
  for s in filter-by<BuildStmt>(stmts(proj)) find :
    name(s) == target

public defn build-target! (proj:ProjFile, target:Symbol) -> BuildStmt :
  val s = build-target(proj, target)
  match(s:BuildStmt) : s
  else : throw(ProjFileError(false, to-string("No build target named %~." % [target])))

;============================================================
;================= Variable Substitution ====================
;============================================================

defn variable-substitution (f:ProjFileS0) :
  ;Compute values of all symbols
  val symbol-table = HashTable<Symbol,ProjValue>()

  ;Accumulate errors
  val errors = Vector<ProjFileError>()

  ;Retrieve a value from the symbol table
  defn get-value! (info:FileInfo|False, name:Symbol) -> ProjValue :
    if not key?(symbol-table, name) :
      val env-v = get-env(to-string(name))
      match(env-v:String) :
        AtomValue(info, env-v)
      else :
        ;Record error
        add(errors, ProjFileError(info, to-string("Cannot resolve variable %_." % [name])))
        ;Return dummy
        VarValue(info, name)
    else :
      sub-info(symbol-table[name], info)
  defn get-value! (info:FileInfo|False, name:String) :
    get-value!(info, to-symbol(name))

  ;Substitute variables into given string
  defn sub-string-vars (info:FileInfo|False, s:String) -> ProjValue :
    within name = sub-curly(info, s) :
      if name == "." : ProjDir(info)
      else if name == "WORKDIR" : WorkDir(info)
      else : get-value!(info,name)

  ;Substitute variables into value
  defn sub-vars (v:ProjValue) -> ProjValue :
    match(v) :
      (v:AtomValue) :
        match(value(v)) :
          (value:String) : sub-string-vars(info(v), value)
          (value:Symbol) : v
      (v:ProjValues) :
        ProjValues(info(v), map(sub-vars, values(v)))
      (v:CondPlatform) :
        CondPlatform(info(v), map-values(sub-vars, values(v)))
      (v:VarValue) :
        get-value!(info(v),name(v))
      (v:CommandString) :
        CommandString(info(v), sub-vars(value(v)))

  ;Wrap command strings
  defn wrap-command-strings (v:ProjValue) -> ProjValue :
    match(v) :
      (v:AtomValue) :
        CommandString(info(v), v)
      (v:ProjValues) :
        ProjValues(info(v), map(wrap-command-strings, values(v)))
      (v:CondPlatform) :
        CondPlatform(info(v), map-values(wrap-command-strings, values(v)))
      (v:VarValue) :
        v

  ;Substitute all variables
  defn sub-vars (s:ProjStmt) -> ProjStmt :
    match(s) :
      (s:IncludedStmtsS0) :
        IncludedStmtsS0(
          info(s),
          path(s),
          full-path(s),
          map(sub-vars, stmts(s)))
      (s:DefinedInStmtS0) :
        DefinedInStmtS0(
          info(s),
          package(s),
          sub-vars(filename(s)))
      (s:PackagesDefinedInStmtS0) :
        PackagesDefinedInStmtS0(
          info(s),
          packages(s),
          sub-vars(filename(s)))
      (s:SyntaxPackagesDefinedInStmtS0) :
        SyntaxPackagesDefinedInStmtS0(
          info(s),
          packages(s),
          sub-vars(filename(s)))
      (s:RequiresStmtS0) :
        RequiresStmtS0(
          info(s),
          package(s),
          maybe?(sub-vars, ccfiles(s)),
          maybe?(sub-vars, ccflags(s)))
      (s:ImportWhenStmtS0) :
        ImportWhenStmtS0(
          info(s),
          package(s),
          sub-vars(dependencies(s)))
      (s:CompileStmtS0) :
        CompileStmtS0(
          info(s)
          file?(s)
          name(s)
          sub-vars(name-value(s)),
          maybe?(sub-vars, dependencies(s))
          sub-vars(wrap-command-strings(commands(s))))
      (s:BuildStmtS0) :
        BuildStmtS0(
          info(s)
          name(s)
          type(s)
          sub-vars(inputs(s))
          maybe?(sub-vars, supported-vm-packages(s))
          maybe?(sub-vars, pkg(s))
          maybe?(sub-vars, output(s))
          maybe?(sub-vars, assembly(s))
          maybe?(sub-vars, external-dependencies(s))
          maybe?(sub-vars, ccfiles(s))
          maybe?(sub-vars, ccflags(s))
          maybe?(sub-vars, flags(s))
          optimize(s))
      (s:VarStmtS0) :
        val value* = sub-vars(value(s))
        symbol-table[name(s)] = value*
        VarStmtS0(info(s), name(s), value*)

  ;Launch!
  val stmts* = map(sub-vars,stmts(f))

  ;Check for errors
  throw(ProjFileErrors(errors)) when not empty?(errors)

  ;Return substituted Project File
  ProjFileS0(path(f), full-path(f), stmts*)


defn sub-curly (f:String -> ProjValue, info:FileInfo|False, s:String) -> ProjValue :
  if index-of-char(s, '{') is False :
    AtomValue(info, s)
  else :
    val buffer = Vector<ProjValue>()

    ;Iterate through the curlies
    let loop (start:Int = 0) :
      ;Determine curly bounds
      val [i, j] = let :
        val i = index-of-char(s, start to false, '{')
        match(i:Int) :
          [i, index-of-char(s, (i + 1) to false, '}')]
        else : [i, false]
      ;If there is a curly
      match(i:Int, j:Int) :
        ;Add string up to curly
        if start < i :
          add(buffer, AtomValue(info, s[start to i]))
        ;Add replacement
        val replacement = f(s[(i + 1) through (j - 1)])
        add(buffer, replacement)
        ;Continue past } char
        loop(j + 1)
      else :
        ;End of string, add the rest
        if start < length(s) :
          add(buffer, AtomValue(info, s[start to false]))

    ;Return spliced string
    SplicedString(info, to-tuple(buffer))



;============================================================
;============ Normalize Statements Under Platform ===========
;============================================================

defn normalize (f:ProjFileS0, current-platform:Symbol) -> ProjFileS0 :
  ;Track errors
  val errors = Vector<ProjFileError>()

  ;----------------------------------------------------------
  ;----------------- Checking Validity ----------------------
  ;----------------------------------------------------------
  defn ensure-stanza-input (v:ProjValue) -> False :
    val stanza-input? =
      match(v) :
        (v:AtomValue) :
          match(value(v)) :
            (value:String) : any?(suffix?{value, _}, [".stanza" ".pkg" ".fpkg"])
            (value:Symbol) : true
        (v:SplicedString) :
          val n = length(values(v))
          val s = to-string(values(v)[n - 1])
          any?(suffix?{s, _}, [".stanza" ".pkg" ".fpkg"])
        (v) : false
    if not stanza-input? :
      add(errors, ProjFileError(info(v), "Expected a stanza input file here."))

  defn ensure-string (v:ProjValue) -> False :
    match(v:AtomValue) :
      if value(v) is Symbol :
        add(errors, ProjFileError(info(v), "Expected a string here."))

  defn ensure-symbol (v:ProjValue) -> False :
    val symbol? = match(v:AtomValue) : value(v) is Symbol
    if not symbol? :
      add(errors, ProjFileError(info(v), "Expected a symbol here."))

  defn ensure-packages-description (info:FileInfo|False, s:Symbol) -> False :
    val [package-name, suffix] = qualifier(s)
    if suffix != `* :
      val msg = "The specifier '%~' is an invalid name for the packages. Expected the packages name to be like this: mypackage/*." % [s]
      add(errors, ProjFileError(info, to-string(msg)))

  ;----------------------------------------------------------
  ;----------------- Retrieve Proper Value(s) ---------------
  ;----------------------------------------------------------
  defn single (name:String, v:ProjValue) -> ProjValue :
    val vs = flatten(norm(v))
    if length(vs) == 1 :
      switch(name) :
        "string" : ensure-string(vs[0])
        "symbol" : ensure-symbol(vs[0])
        "stanza input file" : ensure-stanza-input(vs[0])
      vs[0]
    else :
      add(errors, ProjFileError(info(v), to-string("Expected a single %_ here." % [name])))
      v

  defn multiple (name:String, v:ProjValue) -> ProjValues :
    val vs = flatten(norm(v))
    switch(name) :
      "string" : do(ensure-string, vs)
      "symbol" : do(ensure-symbol, vs)
      "stanza input file" : do(ensure-stanza-input, vs)
    ProjValues(info(v), vs)

  defn command (v:ProjValue) -> ProjValue :
    match(v:CommandString) :
      val strings = multiple("string", value(v))
      CommandString(info(v), strings)
    else :
      add(errors, ProjFileError(info(v), "Expected a compilation command string here."))
      v

  defn commands (v:ProjValue) -> ProjValues :
    val vs = flatten(norm(v))
    val cs = map(command, vs)
    ProjValues(info(v), cs)

  ;------------------------------------------------------------
  ;------------------- Normalize Statements -------------------
  ;------------------------------------------------------------
  defn norm (s:ProjStmt) :
    match(s) :
      (s:IncludedStmtsS0) :
        val stmts* = map(norm, stmts(s))
        IncludedStmtsS0(info(s), path(s), full-path(s), stmts*)
      (s:DefinedInStmtS0) :
        DefinedInStmtS0(info(s),
                        package(s),
                        single("string", filename(s)))
      (s:PackagesDefinedInStmtS0) :
        ensure-packages-description(info(s), packages(s))
        PackagesDefinedInStmtS0(info(s),
                                packages(s),
                                single("string", filename(s)))
      (s:SyntaxPackagesDefinedInStmtS0) :
        SyntaxPackagesDefinedInStmtS0(info(s),
                                      packages(s),
                                      single("string", filename(s)))
      (s:RequiresStmtS0) :
        RequiresStmtS0(info(s),
                       package(s),
                       maybe?(multiple{"string", _}, ccfiles(s)),
                       maybe?(multiple{"string", _}, ccflags(s)))
      (s:ImportWhenStmtS0) :
        ImportWhenStmtS0(info(s),
                         package(s),
                         multiple("symbol", dependencies(s)))
      (s:CompileStmtS0) :
        CompileStmtS0(info(s),
                      file?(s),
                      name(s),
                      single("string", name-value(s)),
                      maybe?(multiple{"string", _}, dependencies(s)),
                      commands(/commands(s)))
      (s:BuildStmtS0) :
        BuildStmtS0(info(s),
                    name(s),
                    type(s),
                    multiple("stanza input file", inputs(s)),
                    maybe?(multiple{"stanza input file", _}, supported-vm-packages(s)),
                    maybe?(single{"string", _}, pkg(s)),
                    maybe?(single{"string", _}, output(s)),
                    maybe?(single{"string", _}, assembly(s)),
                    maybe?(single{"string", _}, external-dependencies(s))
                    maybe?(multiple{"string", _}, ccfiles(s)),
                    maybe?(multiple{"string", _}, ccflags(s)),
                    maybe?(multiple{"symbol", _}, flags(s)),
                    optimize(s))
      (s:VarStmtS0) :
        s

  ;Normalize a value (evaluate all platform switches, and separate spliced strings)
  defn norm (v:ProjValue) -> ProjValue :
    match(v) :
      (v:AtomValue|ProjDir|WorkDir) :
        v
      (v:ProjValues) :
        ProjValues(info(v), map(norm,values(v)))
      (v:SplicedString) :
        separate(SplicedString(info(v), map(norm,values(v))))
      (v:CondPlatform) :
        val v* = for e in values(v) first :
          if key(e) == current-platform or key(e) == `else :
            One(norm(value(e)))
          else : None()
        value!(v*)
      (v:CommandString) :
        CommandString(info(v), norm(value(v)))

  ;----------------------------------------------------------
  ;-------------------- Launch ------------------------------
  ;----------------------------------------------------------
  ;Launch!
  val stmts* = map(norm, stmts(f))
  ;Check for errors
  throw(ProjFileErrors(errors)) when not empty?(errors)
  ;Return file
  ProjFileS0(path(f), full-path(f), stmts*)

;Remove ProjValues nested within ProjValues
defn flatten (v:ProjValue) -> Tuple<ProjValue> :
  match(v:ProjValues) :
    val accum = Vector<ProjValue>()
    let loop (v:ProjValue = v) :
      match(v:ProjValues) : do(loop, values(v))
      else : add(accum,v)
    to-tuple(accum)
  else :
    [v]

;Separate a spliced string into a tuple of project values
;if necessary.
defn separate (s:SplicedString) -> ProjValue :
  ;Create buffer of values and separators
  val buffer = Vector<ProjValue|Separator>()

  ;Recursively add all values to buffer (with separators if necessary.)
  defn add-to-buffer (v:ProjValue) :
    val counter = to-seq(0 to false)
    let loop (v:ProjValue = v) :
      match(v) :
        (v:ProjValues) :
          do(loop, values(v))
        (v) :
          add(buffer, Separator()) when next(counter) > 0
          add(buffer, v)
  do(add-to-buffer, values(s))

  ;Join all pieces in the buffer
  val joined-buffer = Vector<ProjValue>()
  val buffer-seq = to-seq(buffer)
  while not empty?(buffer-seq) :
    ;Take until next separator
    val values = to-tuple $ take-while({_ is ProjValue}, buffer-seq)
    ;Add to joined buffer
    if length(values) == 1 : add(joined-buffer, values[0] as ProjValue)
    else : add(joined-buffer, SplicedString(info(s), values as Tuple<ProjValue>))
    ;Eat separator
    next(buffer-seq) when not empty?(buffer-seq)

  ;Return cases
  if length(joined-buffer) == 1 : joined-buffer[0]
  else : ProjValues(info(s), to-tuple(joined-buffer))

defstruct Separator

;============================================================
;=============== Flatten Relative Paths =====================
;============================================================
defn flatten-relative-paths (f:ProjFileS0) -> ProjFile :
  ;Compute working directory
  val workdir = resolve-path(".") as String

  ;Accumulate flattened statements
  val accum = Vector<ProjStmt>()
  defn emit (s:ProjStmt) : add(accum,s)

  ;Substitute directories
  defn sub-dirs (v:ProjValue, projdir:String) -> String|Symbol :
    defn value-string (v:ProjValue) -> String :
      match(v) :
        (v:WorkDir) : workdir
        (v:ProjDir) : projdir
        (v:AtomValue) : to-string(value(v))
    match(v) :
      (v:WorkDir|ProjDir) : value-string(v)
      (v:SplicedString) : string-join $ seq(value-string,values(v))
      (v:AtomValue) : value(v)

  ;Process statement and sub-statements and push into accumulator.
  defn process (s:ProjStmt, parent-path:String, parent-full-path:String) :
    ;Compute the project dir
    val proj-dir = to-string(enclosing-dir(parent-full-path))

    ;If s is a string then assume that it is a filename and add a directory so it
    ;such that it is relative to the correct directory.
    defn add-dir-to-path (s:String|Symbol) :
      match(s:String) : relative-to-file(parent-path, s)
      else : s

    defn to-path (v:ProjValue) -> String|Symbol :
      add-dir-to-path(sub-dirs(v, proj-dir))
    defn to-input (v:ProjValue) -> String|Symbol :
      sub-dirs(v, proj-dir)
    defn to-paths (v:ProjValue) -> Tuple<String|Symbol> :
      map(to-path, values(v as ProjValues))
    defn to-inputs (v:ProjValue) -> Tuple<String|Symbol> :
      map(to-input, values(v as ProjValues))
    defn to-commands (v:ProjValue) -> Tuple<String> :
      for c in values(v as ProjValues) map :
        val strings = to-inputs(value(c as CommandString))
        string-join(strings as Tuple<String>, " ")

    match(s) :
      (s:IncludedStmtsS0) :
        do(process{_, path(s), full-path(s)}, stmts(s))
      (s:DefinedInStmtS0) :
        emit $ DefinedInStmt(package(s),
                             to-path(filename(s)) as String)
      (s:PackagesDefinedInStmtS0) :
        val [package-name, suffix] = qualifier(packages(s))
        emit $ PackagesDefinedInStmt(package-name,
                                     to-path(filename(s)) as String)
      (s:SyntaxPackagesDefinedInStmtS0) :
        emit $ SyntaxPackagesDefinedInStmt(packages(s),
                                           to-path(filename(s)) as String)
      (s:RequiresStmtS0) :
        emit $ RequiresStmt(package(s),
                            tuple?(to-paths,ccfiles(s)) as Tuple<String>,
                            tuple?(to-inputs,ccflags(s)) as Tuple<String>)
      (s:ImportWhenStmtS0) :
        emit $ ImportWhenStmt(package(s),
                              to-inputs(dependencies(s)) as Tuple<Symbol>)
      (s:CompileStmtS0) :
        val name* = to-path(name-value(s)) when file?(s) else to-input(name-value(s))
        emit $ CompileStmt(file?(s),
                           name* as String,
                           tuple?(to-paths,dependencies(s)) as Tuple<String>,
                           to-commands(commands(s)))
      (s:BuildStmtS0) :
        emit $ BuildStmt(
          name(s)
          type(s)
          to-paths(inputs(s))
          tuple?(to-paths, supported-vm-packages(s))
          maybe?(to-path, pkg(s)) as Maybe<String>
          maybe?(to-path, output(s)) as Maybe<String>
          maybe?(to-path, assembly(s)) as Maybe<String>
          maybe?(to-path, external-dependencies(s)) as Maybe<String>
          tuple?(to-paths, ccfiles(s)) as Tuple<String>
          tuple?(to-inputs, ccflags(s)) as Tuple<String>
          tuple?(to-inputs, flags(s)) as Tuple<Symbol>
          optimize(s))
      (s:VarStmtS0) :
        false

  ;Launch!
  do(process{_, path(f), full-path(f)}, stmts(f))

  ;Return new project file
  ProjFile(to-tuple(accum))

;Helper: Assuming that 'relpath' is a path specified relative
;to 'file' return the full path.
defn relative-to-file (file:String, relpath:String) -> String :
  to-string(relative-to-file(parse-path(file), relpath))

;============================================================
;=================== Combine Files ==========================
;============================================================
defn combine (fs:Seqable<ProjFile>) -> ProjFile :
  ;Get all statements in a vector.
  val all-stmts = to-vector<ProjStmt>(seq-cat(stmts, fs))

  ;Remove duplicate statements.
  reverse!(all-stmts)
  val visited-set = HashSet<[Symbol,?]>()
  for s in all-stmts remove-when :
    val key = match(s) :
      (s:DefinedInStmt) : [`DefinedInStmt, package(s)]
      (s:PackagesDefinedInStmt) : [`PackagesDefinedInStmt, packages(s)]
      (s:SyntaxPackagesDefinedInStmt) : [`SyntaxPackagesDefinedInStmt, packages(s)]
      (s:RequiresStmt) : [`RequiresStmt, package(s)]
      (s:ImportWhenStmt) : [`ImportWhenStmt, package(s)]
      (s:CompileStmt) : [`CompileStmt, name(s)]
      (s:BuildStmt) : [`BuildStmt, name(s)]
    not add(visited-set, key)
  reverse!(all-stmts)

  ;Return combined project file.
  ProjFile(to-tuple(all-stmts))

;============================================================
;======================== Utilities =========================
;============================================================

defn maybe?<?T,?S> (f:T -> ?S, x:Maybe<?T>) -> Maybe<S> :
  if empty?(x) : None()
  else : One(f(value!(x)))

defn tuple?<?T,?S> (f:T -> Tuple<?S>, x:Maybe<?T>) -> Tuple<S> :
  if empty?(x) : []
  else : f(value!(x))

defn map-values<?K,?V1,?V2> (f:V1 -> ?V2, xs:Tuple<KeyValue<?K,?V1>>) :
  for x in xs map : key(x) => f(value(x))