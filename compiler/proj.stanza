defpackage stz/proj :
  import core
  import collections
  import reader
  import stz/params
  import stz/utils
  import core/parsed-path
  import stz/timing-log-api
  import stz/proj-env
  import stz/proj-errors
  import stz/proj-ir
  import stz/proj-reader
  import stz/proj-stage0
  import stz/proj-wellformedness
  import stz/proj-traverse-includes
  import stz/proj-variable-substitution
  import stz/proj-isolate-package-manager-params
  import stz/proj-normalization
  import stz/proj-post-checks
  import stz/proj-flattening
  import stz/proj-conversion
  import stz/proj-value-types

;============================================================
;======================= Timers =============================
;============================================================

val READ-PROJ-FILES = TimerLabel("Read Proj Files")
val NORMALIZE = TimerLabel(READ-PROJ-FILES, suffix("Normalize"))
val VARIABLE-SUBSTITUTION = TimerLabel(READ-PROJ-FILES, suffix("Variable Substitution"))

;============================================================
;======================== Driver ============================
;============================================================

public defn read-proj-files (filenames:Seqable<String>,
                             platform:Symbol,
                             env:ProjEnv) -> ProjFile :  
  ;Return a new function that performs the same thing as stage,
  ;except that it is timed and attributed towards 'tlabel'.
  defn time<T,?S> (tlabel:TimerLabel, stage:T -> ?S) :
    fn (x:T) -> S :
      within log-time(tlabel) :
        stage(x)

  ;Helper: Read a projfile and ensure it is wellformed.
  val wellformedness = ProjWellformedness(platform, env)
  defn read-wellformed-file (filename:String) -> ProjFileS0 :
    filename $> time<String>(READ-PROJ-FILES, read-raw-proj-file)
             $> check{wellformedness, _}

  ;Stage: Read all the files, ensuring they are wellformed, and traverse
  ;through include files.
  defn read-files-deeply (filenames:Seqable<String>) -> Tuple<ProjFileS0> :
    to-tuple $ for file in filenames seq :
      file $> read-wellformed-file
           $> traverse-includes{_, read-wellformed-file}

  ;Stage: Finish all postprocessing stages to get files into final form.
  defn sub-variables-and-finish-processing (files:Tuple<ProjFileS0>,
                                            vartable:HashTable<Symbol,ProjValue>) -> ProjFile :
    val new-files = for file in files map :
      file $> variable-substitution{_, vartable}
           $> normalize{_, platform, workdir(env)}
           $> post-normalization-checks{_, env}
           $> flatten-relative-paths
    new-files $> combine
              $> convert-proj{_, env}

  ;Stage: Compute new substitution variables.
  defn compute-package-manager-variables (f:ProjFile) -> Tuple<KeyValue<Symbol,?>> :
    to-tuple $ for file-stmt in stmts(f) seq-cat :
      val stmt = file-stmt as ForeignPackageParamsStmt
      val entries = package-manager-variables(env, stmt, platform)
      ;Sanity check.
      for e in entries do :
        if not wellformed-var-value?(value(e)) :
          fatal("The package manager %_ returned an illegal value of type %_ for the variable '%~': %~." % [
            package-manager(stmt), object-type(value(e)), key(e), value(e)])
      ;Keep entries
      entries

  ;Helper: Add the additional variables to the given vartable.
  defn add-additional-variables (vartable:HashTable<Symbol,ProjValue>,
                                 entries:Tuple<KeyValue<Symbol,?>>) -> False :
    for e in entries do :
      vartable[key(e)] = translate-to-proj-value(value(e))

  ;Launch!
  val read-files = read-files-deeply(filenames)
  val var-table = build-variable-table(read-files)
  println("Variable Table")
  do(println, var-table)
  val [files-with-params, files-without-params] = isolate-package-manager-params(read-files)
  println("FILES WITH PARAMS")
  do(println, files-with-params)
  println("FILES WITHOUT PARAMS")
  do(println, files-without-params)

  if not empty?(files-with-params) :
    val new-files-with-params = sub-variables-and-finish-processing(files-with-params, var-table)
    println("Evaluated params")
    println(new-files-with-params)
    val new-entries = compute-package-manager-variables(new-files-with-params)
    println("New-entries:")
    within indented() :
      do(println, new-entries)
    add-additional-variables(var-table, new-entries)
  
  ;Perform the final processing remaining statements with the new additional variables.
  if not empty?(files-without-params) :
    sub-variables-and-finish-processing(files-without-params, var-table)
  else :
    ProjFile([])

;============================================================
;========== S-Expression to ProjValue Translation ===========
;============================================================

;Returns true if x is a wellformed value that can be
;translated into a ProjValue.
defn wellformed-var-value? (x) -> True|False :
  match(x) :
    (x:Symbol|String) : true
    (x:List) : all?(wellformed-var-value?, x)
    (x) : false

;Translate a value from the foreign package manager into
;the ProjValue used by the variable substitution algorithm.
defn translate-to-proj-value (x) -> ProjValue :
  match(x) :
    (x:Symbol|String) : AtomValue(false, x)
    (x:List) : ProjValues(false, to-tuple(seq(translate-to-proj-value, x)))

;============================================================
;===== All Project Files by Default During Compilation ======
;============================================================

public defn default-proj-files () -> Vector<String> :
  val files = Vector<String>()
  add(files, string-join $ [STANZA-INSTALL-DIR, "/stanza.proj"])
  add-all(files, STANZA-PROJ-FILES)
  add(files, "stanza.proj") when file-exists?("stanza.proj")
  files

;============================================================
;================ Retrieve a Build Target ===================
;============================================================

public defn build-target (proj:ProjFile, target:Symbol) -> BuildStmt|False :
  for s in filter-by<BuildStmt>(stmts(proj)) find :
    name(s) == target

public defn build-target! (proj:ProjFile, target:Symbol) -> BuildStmt :
  val s = build-target(proj, target)
  match(s:BuildStmt) : s
  else : throw(ProjFileError(false, to-string("No build target named %~." % [target])))

;============================================================
;=================== Combine Files ==========================
;============================================================
defn combine (fs:Tuple<ProjFileS0>) -> ProjFileS0 :
  ;Get all statements in a vector.
  val all-stmts = to-vector<ProjStmt>(seq-cat(stmts, fs))

  ;Remove duplicate statements.
  reverse!(all-stmts)
  val visited-set = HashSet<?>()
  for stmt in all-stmts remove-when :
    val key = duplication-key(stmt)
    if key is False : false
    else : not add(visited-set, key)
  reverse!(all-stmts)

  ;Return combined project file.
  sub-stmts(fs[0], to-tuple(all-stmts))