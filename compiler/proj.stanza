defpackage stz/proj :
  import core
  import collections
  import reader
  import stz/params
  import stz/utils
  import core/parsed-path
  import stz/timing-log-api
  import stz/proj-errors
  import stz/proj-ir
  import stz/proj-reader
  import stz/proj-stage0
  import stz/proj-wellformedness
  import stz/proj-traverse-includes
  import stz/proj-variable-substitution
  import stz/proj-normalization
  import stz/proj-post-checks

;============================================================
;======================= Timers =============================
;============================================================

val READ-PROJ-FILES = TimerLabel("Read Proj Files")
val FLATTEN-RELATIVE-PATHS = TimerLabel(READ-PROJ-FILES, suffix("Flatten Relative Paths"))
val NORMALIZE = TimerLabel(READ-PROJ-FILES, suffix("Normalize"))
val VARIABLE-SUBSTITUTION = TimerLabel(READ-PROJ-FILES, suffix("Variable Substitution"))

;============================================================
;======================== Driver ============================
;============================================================

public defn read-proj-files (filenames:Seqable<String>, platform:Symbol) -> ProjFile :
  ;Return a new function that performs the same thing as stage,
  ;except that it is timed and attributed towards 'tlabel'.
  defn time<T,?S> (tlabel:TimerLabel, stage:T -> ?S) :
    fn (x:T) -> S :
      within log-time(tlabel) :
        stage(x)

  ;Helper: Read a projfile and ensure it is wellformed.
  defn read-wellformed-file (filename:String) -> ProjFileS0 :
    filename $> read-raw-proj-file
             $> ensure-wellformed{_, platform}
        
  combine $ for filename in filenames seq :
    filename $> read-wellformed-file
             $> traverse-includes{_, read-wellformed-file}
             $> time<ProjFileS0>(VARIABLE-SUBSTITUTION, variable-substitution)
             $> time<ProjFileS0>(NORMALIZE, normalize{_, platform})
             $> post-normalization-checks
             $> fn (p) : (println(p), fatal("Stop here"))
;             $> fn (p) : (println(p), p)
;             $> time<ProjFileS0>(FLATTEN-RELATIVE-PATHS, flatten-relative-paths)

;============================================================
;===== All Project Files by Default During Compilation ======
;============================================================

public defn default-proj-files () -> Vector<String> :
  val files = Vector<String>()
  add(files, string-join $ [STANZA-INSTALL-DIR, "/stanza.proj"])
  add-all(files, STANZA-PROJ-FILES)
  add(files, "stanza.proj") when file-exists?("stanza.proj")
  files

;============================================================
;================ Retrieve a Build Target ===================
;============================================================

public defn build-target (proj:ProjFile, target:Symbol) -> BuildStmt|False :
  for s in filter-by<BuildStmt>(stmts(proj)) find :
    name(s) == target

public defn build-target! (proj:ProjFile, target:Symbol) -> BuildStmt :
  val s = build-target(proj, target)
  match(s:BuildStmt) : s
  else : throw(ProjFileError(false, to-string("No build target named %~." % [target])))



;============================================================
;=============== Flatten Relative Paths =====================
;============================================================
defn flatten-relative-paths (f:ProjFileS0) -> ProjFile :
  ;Compute working directory
  val workdir = resolve-path(".") as String

  ;Accumulate flattened statements
  val accum = Vector<ProjStmt>()
  defn emit (s:ProjStmt) : add(accum,s)

  ;Substitute directories
  defn sub-dirs (v:ProjValue, projdir:String) -> String|Symbol :
    defn value-string (v:ProjValue) -> String :
      match(v) :
        (v:WorkDir) : workdir
        (v:ProjDir) : projdir
        (v:AtomValue) : to-string(value(v))
    match(v) :
      (v:WorkDir|ProjDir) : value-string(v)
      (v:SplicedString) : string-join $ seq(value-string,values(v))
      (v:AtomValue) : value(v)

  ;Process statement and sub-statements and push into accumulator.
  defn process (s:ProjStmt, parent-path:String, parent-full-path:String) :
    ;Compute the project dir
    val proj-dir = to-string(enclosing-dir(parent-full-path))

    ;If s is a string then assume that it is a filename and add a directory so it
    ;such that it is relative to the correct directory.
    defn add-dir-to-path (s:String|Symbol) :
      match(s:String) : relative-to-file(parent-path, s)
      else : s

    defn to-path (v:ProjValue) -> String|Symbol :
      add-dir-to-path(sub-dirs(v, proj-dir))
    defn to-input (v:ProjValue) -> String|Symbol :
      sub-dirs(v, proj-dir)
    defn to-paths (v:ProjValue) -> Tuple<String|Symbol> :
      map(to-path, values(v as ProjValues))
    defn to-inputs (v:ProjValue) -> Tuple<String|Symbol> :
      map(to-input, values(v as ProjValues))
    defn to-commands (v:ProjValue) -> Tuple<String> :
      for c in values(v as ProjValues) map :
        val strings = to-inputs(value(c as CommandString))
        string-join(strings as Tuple<String>, " ")

    match(s) :
      (s:IncludedStmtsS0) :
        do(process{_, path(s), full-path(s)}, stmts(s))
      (s:DefinedInStmtS0) :
        emit $ DefinedInStmt(package(s),
                             to-path(filename(s)) as String)
      (s:PackagesDefinedInStmtS0) :
        val [package-name, suffix] = qualifier(packages(s))
        emit $ PackagesDefinedInStmt(package-name,
                                     to-path(filename(s)) as String)
      (s:SyntaxPackagesDefinedInStmtS0) :
        emit $ SyntaxPackagesDefinedInStmt(packages(s),
                                           to-path(filename(s)) as String)
      (s:RequiresStmtS0) :
        emit $ RequiresStmt(package(s),
                            tuple?(to-paths,ccfiles(s)) as Tuple<String>,
                            tuple?(to-inputs,ccflags(s)) as Tuple<String>)
      (s:ImportWhenStmtS0) :
        emit $ ImportWhenStmt(package(s),
                              to-inputs(dependencies(s)) as Tuple<Symbol>)
      (s:CompileStmtS0) :
        val name* = to-path(name-value(s)) when file?(s) else to-input(name-value(s))
        emit $ CompileStmt(file?(s),
                           name* as String,
                           tuple?(to-paths,dependencies(s)) as Tuple<String>,
                           to-commands(commands(s)))
      (s:BuildStmtS0) :
        emit $ BuildStmt(
          name(s)
          type(s)
          to-paths(inputs(s))
          tuple?(to-paths, supported-vm-packages(s))
          maybe?(to-path, pkg(s)) as Maybe<String>
          maybe?(to-path, output(s)) as Maybe<String>
          maybe?(to-path, assembly(s)) as Maybe<String>
          maybe?(to-path, external-dependencies(s)) as Maybe<String>
          tuple?(to-paths, ccfiles(s)) as Tuple<String>
          tuple?(to-inputs, ccflags(s)) as Tuple<String>
          tuple?(to-inputs, flags(s)) as Tuple<Symbol>
          optimize(s))
      (s:VarStmtS0) :
        false

  ;Launch!
  do(process{_, path(f), full-path(f)}, stmts(f))

  ;Return new project file
  ProjFile(to-tuple(accum))

;Helper: Assuming that 'relpath' is a path specified relative
;to 'file' return the full path.
defn relative-to-file (file:String, relpath:String) -> String :
  to-string(relative-to-file(parse-path(file), relpath))

;============================================================
;=================== Combine Files ==========================
;============================================================
defn combine (fs:Seqable<ProjFile>) -> ProjFile :
  ;Get all statements in a vector.
  val all-stmts = to-vector<ProjStmt>(seq-cat(stmts, fs))

  ;Remove duplicate statements.
  reverse!(all-stmts)
  val visited-set = HashSet<[Symbol,?]>()
  for s in all-stmts remove-when :
    val key = match(s) :
      (s:DefinedInStmt) : [`DefinedInStmt, package(s)]
      (s:PackagesDefinedInStmt) : [`PackagesDefinedInStmt, packages(s)]
      (s:SyntaxPackagesDefinedInStmt) : [`SyntaxPackagesDefinedInStmt, packages(s)]
      (s:RequiresStmt) : [`RequiresStmt, package(s)]
      (s:ImportWhenStmt) : [`ImportWhenStmt, package(s)]
      (s:CompileStmt) : [`CompileStmt, name(s)]
      (s:BuildStmt) : [`BuildStmt, name(s)]
    not add(visited-set, key)
  reverse!(all-stmts)

  ;Return combined project file.
  ProjFile(to-tuple(all-stmts))

;============================================================
;======================== Utilities =========================
;============================================================

defn maybe?<?T,?S> (f:T -> ?S, x:Maybe<?T>) -> Maybe<S> :
  if empty?(x) : None()
  else : One(f(value!(x)))

defn tuple?<?T,?S> (f:T -> Tuple<?S>, x:Maybe<?T>) -> Tuple<S> :
  if empty?(x) : []
  else : f(value!(x))

defn map-values<?K,?V1,?V2> (f:V1 -> ?V2, xs:Tuple<KeyValue<?K,?V1>>) :
  for x in xs map : key(x) => f(value(x))