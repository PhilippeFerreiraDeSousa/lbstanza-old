defpackage stz/proj :
  import core
  import collections
  import reader
  import stz/params
  import stz/utils
  import core/parsed-path
  import stz/timing-log-api
  import stz/proj-errors
  import stz/proj-ir
  import stz/proj-reader
  import stz/proj-stage0
  import stz/proj-wellformedness
  import stz/proj-traverse-includes
  import stz/proj-variable-substitution
  import stz/proj-normalization
  import stz/proj-post-checks
  import stz/proj-flattening

;============================================================
;======================= Timers =============================
;============================================================

val READ-PROJ-FILES = TimerLabel("Read Proj Files")
val FLATTEN-RELATIVE-PATHS = TimerLabel(READ-PROJ-FILES, suffix("Flatten Relative Paths"))
val NORMALIZE = TimerLabel(READ-PROJ-FILES, suffix("Normalize"))
val VARIABLE-SUBSTITUTION = TimerLabel(READ-PROJ-FILES, suffix("Variable Substitution"))

;============================================================
;======================== Driver ============================
;============================================================

public defn read-proj-files (filenames:Seqable<String>, platform:Symbol) -> ProjFile :
  ;Return a new function that performs the same thing as stage,
  ;except that it is timed and attributed towards 'tlabel'.
  defn time<T,?S> (tlabel:TimerLabel, stage:T -> ?S) :
    fn (x:T) -> S :
      within log-time(tlabel) :
        stage(x)

  ;Helper: Read a projfile and ensure it is wellformed.
  defn read-wellformed-file (filename:String) -> ProjFileS0 :
    filename $> read-raw-proj-file
             $> ensure-wellformed{_, platform}
        
  println $ combine $ to-tuple $
    for filename in filenames seq :
      filename $> read-wellformed-file
               $> traverse-includes{_, read-wellformed-file}
               $> time<ProjFileS0>(VARIABLE-SUBSTITUTION, variable-substitution)
               $> time<ProjFileS0>(NORMALIZE, normalize{_, platform})
               $> post-normalization-checks
               $> flatten-relative-paths

  ;Still need combining
  fatal("Combine")

;             $> fn (p) : (println(p), p)
;             $> time<ProjFileS0>(FLATTEN-RELATIVE-PATHS, flatten-relative-paths)

;============================================================
;===== All Project Files by Default During Compilation ======
;============================================================

public defn default-proj-files () -> Vector<String> :
  val files = Vector<String>()
  add(files, string-join $ [STANZA-INSTALL-DIR, "/stanza.proj"])
  add-all(files, STANZA-PROJ-FILES)
  add(files, "stanza.proj") when file-exists?("stanza.proj")
  files

;============================================================
;================ Retrieve a Build Target ===================
;============================================================

public defn build-target (proj:ProjFile, target:Symbol) -> BuildStmt|False :
  for s in filter-by<BuildStmt>(stmts(proj)) find :
    name(s) == target

public defn build-target! (proj:ProjFile, target:Symbol) -> BuildStmt :
  val s = build-target(proj, target)
  match(s:BuildStmt) : s
  else : throw(ProjFileError(false, to-string("No build target named %~." % [target])))

;============================================================
;=================== Combine Files ==========================
;============================================================
defn combine (fs:Tuple<ProjFileS0>) -> ProjFileS0 :
  ;Get all statements in a vector.
  val all-stmts = to-vector<ProjStmt>(seq-cat(stmts, fs))

  ;Remove duplicate statements.
  reverse!(all-stmts)
  val visited-set = HashSet<?>()
  for stmt in all-stmts remove-when :
    val key = duplication-key(stmt)
    if key is False : false
    else : not add(visited-set, key)
  reverse!(all-stmts)

  ;Return combined project file.
  sub-stmts(fs[0], to-tuple(all-stmts))

;============================================================
;======================== Utilities =========================
;============================================================

defn maybe?<?T,?S> (f:T -> ?S, x:Maybe<?T>) -> Maybe<S> :
  if empty?(x) : None()
  else : One(f(value!(x)))

defn tuple?<?T,?S> (f:T -> Tuple<?S>, x:Maybe<?T>) -> Tuple<S> :
  if empty?(x) : []
  else : f(value!(x))

defn map-values<?K,?V1,?V2> (f:V1 -> ?V2, xs:Tuple<KeyValue<?K,?V1>>) :
  for x in xs map : key(x) => f(value(x))