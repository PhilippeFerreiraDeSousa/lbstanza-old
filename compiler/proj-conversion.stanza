defpackage stz/proj-conversion :
  import core
  import collections
  import stz/proj-ir
  import stz/proj-stage0
  import stz/proj-errors

;Create the new ProjFile.
public defn convert-proj (proj:ProjFileS0) -> ProjFile :
  val new-stmts = filter-by<ProjStmt>(seq(convert-stmt, stmts(proj)))
  ProjFile(to-tuple(new-stmts))

;Convert the given statement to the final form of the ProjStmt.
;Or false, if the statement should be excluded from the final ProjFile.
defn convert-stmt (stmt:ProjStmt) -> ProjStmt|False :
  match(stmt) :
    (stmt:IncludeStmtS0) :
      false
    (stmt:VarStmtS0) :
      false
    (stmt:DefinedInStmtS0) :
      DefinedInStmt(
        package(stmt),
        single(filename(stmt)))
    (stmt:PackagesDefinedInStmtS0) :
      PackagesDefinedInStmt(
        packages(stmt),
        single(filename(stmt)))
    (stmt:RequiresStmtS0) :
      RequiresStmt(
        package(stmt),
        multiple(ccfiles(stmt)),
        multiple(ccflags(stmt)))
    (stmt:ImportWhenStmtS0) :
      ImportWhenStmt(
        package(stmt),
        multiple(dependencies(stmt)))
    (stmt:CompileStmtS0) :
      CompileStmt(
        file?(stmt),
        single(name(stmt)),
        multiple(dependencies(stmt))
        multiple(commands(stmt)))
    (stmt:BuildStmtS0) :
      BuildStmt(
        name(stmt),
        type(stmt),
        multiple(inputs(stmt)),
        multiple(supported-vm-packages(stmt)),
        single(pkg(stmt)),
        single(output(stmt)),
        single(assembly(stmt)),
        single(external-dependencies(stmt)),
        multiple(ccfiles(stmt)),
        multiple(ccflags(stmt)),
        multiple(flags(stmt)),
        optimize(stmt))
    (stmt:SyntaxPackagesDefinedInStmtS0) :
      SyntaxPackagesDefinedInStmt(
        packages(stmt),
        single(filename(stmt)))

;============================================================
;================= Extraction Helpers =======================
;============================================================

;Extract a single value.
defn single (v:ProjValue) -> ? :
  match(v) :
    (v:AtomValue) : value(v)
    (v:CommandString) : single(value(v))
    (v:FilePath) : single(value(v))

;Extract a single value if there is one.
defn single (v:Maybe<ProjValue>) -> Maybe :
  if empty?(v) : None()
  else : One(single(value!(v)))

;Extract multiple values.
defn multiple (v:ProjValue) -> Tuple :
  match(v) :
    (v:FilePath) :
      multiple(value(v))
    (v:CommandString) :
      multiple(value(v))
    (v:ProjValues) :
      map(single, values(v))
    (v:ProjValue) :
      [single(v)]

;Extract multiple values, or return []
;if there are none.
defn multiple (v:Maybe<ProjValue>) -> Tuple :
  if empty?(v) : []
  else : multiple(value!(v))