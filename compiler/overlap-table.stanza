defpackage stz/overlap-table :
  import core
  import collections

;A simple table to count the number of pairwise overlaps between items.
;Contains a simple optimization for items that are equivalent, and have the
;complete set of pairwise overlaps.
public deftype OverlapTable

;Add a set of disjoint groups to the overlap table.
public defmulti add-groups (t:OverlapTable, groups:Seqable<Seqable<Int>>) -> False

;Add a pairwise overlap to the overlap table.
public defmulti add-overlap (t:OverlapTable, x:Int, y:Int) -> False

;Retrieve the number of overlaps in total between x and y.
public defmulti num-overlaps (t:OverlapTable, x:Int, y:Int) -> Int

;Partition the given groups using the given layers of disjoint groups.
public defmulti partition (t:OverlapTable, groups:Seqable<Seqable<Int>>) -> Seqable<List<Int>>

;Create the overlap table.
public defn OverlapTable (n:Int) -> OverlapTable :

  ;Track the layers of disjoint groups.
  val layers = Vector<DisjointGroups>()

  ;Track the pairwise overlaps
  val pairwise-overlaps = HashTable<[Int,Int],Int>(0)

  ;Create the key for the pairwise table.
  defn pairwise-key (x:Int, y:Int) -> [Int, Int] :
    [x, y] when x < y else [y, x]

  ;Partition the given groups through the layers of groups.
  defn partition-groups (groups:Seqable<Seqable<Int>>) -> Seq<List<Int>> :

    ;Partition a single group using the given layer of disjoint groups.
    defn partition (group:Seqable<Int>, layer:DisjointGroups) -> Seq<List<Int>> :
      val partitions = Array<List<Int>>(num-groups(layer), List())
      for v in group do :
        val i = markers(layer)[v]
        match(i:Int) :
          partitions[i] = cons(v, partitions[i])
      filter({not empty?(_)}, partitions)

    ;Partition a set of groups.
    ;- num-layers: The number of group layers that have already been processed.
    ;  Initial value should be 0.
    defn partition (groups:Seq<Seqable<Int>>, num-layers:Int) -> Seq<List<Int>> :
      if empty?(groups) or num-layers == length(layers) :
        seq(to-list, groups)
      else :
        val new-partitions = for group in groups seq-cat :
          partition(group, layers[num-layers])
        partition(new-partitions, num-layers + 1)

    ;Launch!
    partition(to-seq(groups), 0)

  ;Create the overlap table.
  new OverlapTable :
  
    ;Add a set of disjoint groups to the overlap table.
    defmethod add-groups (this, new-groups:Seqable<Seqable<Int>>) -> False :
      val group-counter = to-seq(0 to false)
      val markers = Array<Int|False>(n,false)
      for (group in new-groups, marker in 0 to false) do :
        next(group-counter)
        for i in group do :
          fatal("Groups are not disjoint.") when markers[i] is Int
          markers[i] = marker
      add(layers, DisjointGroups(peek(group-counter), markers))

    ;Add a pairwise overlap to the overlap table.
    defmethod add-overlap (this, x:Int, y:Int) -> False :
      fatal("Not distinct: %_" % [x]) when x == y
      update(pairwise-overlaps, {_ + 1}, pairwise-key(x,y))
      false

    ;Retrieve the total number of overlaps.
    defmethod num-overlaps (this, x:Int, y:Int) -> Int :
    
      ;Count the number of grouped overlaps.
      val group-overlaps = sum $
        for layer in layers seq :
          match(markers(layer)[x], markers(layer)[y]) :
            (gx:Int, gy:Int) : 1 when gx == gy else 0
            (gx, gy) : 0

      ;Add the number of pairwise overlaps.
      pairwise-overlaps[pairwise-key(x,y)] + group-overlaps

    ;Partition the given groups using the groups that
    ;have already been added.
    defmethod partition (this, groups:Seqable<Seqable<Int>>) -> Seqable<List<Int>> :
      partition-groups(groups)

;Holds a representation of a number of disjoint groups.
;- markers: markers[i] indicates what group i is in.
;- num-groups: indicates how many groups there are in total.
defstruct DisjointGroups :
  num-groups:Int
  markers:Array<Int|False>