defpackage stz/fastio-rw :
  import core
  import collections
  import stz/fastio-buffer
  import stz/serializer

;============================================================
;===================== AST Definition =======================
;============================================================

public deftype Exp

public defstruct PlusExp <: Exp :
  a:Exp
  b:Exp
with:
  printer => true
  
public defstruct MinusExp <: Exp :
  a:Exp
  b:Exp
with:
  printer => true

public defstruct NumExp <: Exp :
  value:Int
with:
  printer => true

public defstruct FuncExp <: Exp :
  f:Exp
  args:Tuple<Exp>
with:
  printer => true

;============================================================
;=================== Serializer Definition ==================
;============================================================

#with-added-syntax(fastio-serializer) :
  defserializer ExpSerializer :
    entry-points: (exp)
    
    defatom int (x:Int) :
      writer:
        write-int(#buffer, x)
      reader:
        read-int(#buffer)
        
    defcombinator tuple (item:X) (x:Tuple<X>) :
      writer :
        #write[int](length(x))
        for xi in x do :
          #write[item](xi)
      reader :
        val len = #read[int]
        val accum = Array<X>(len)
        for i in 0 to len do :
          accum[i] = #read[item]
        to-tuple(accum)

    defunion exp (Exp) :
      PlusExp: (a:exp, b:exp)
      MinusExp: (a:exp, b:exp)
      NumExp: (value:int)
      FuncExp: (f:exp, args:tuple(exp))

#with-added-syntax(stz-serializer-lang) :
  defserializer (out:FileOutputStream, in:FileInputStream) :

    defunion exp (Exp) :
      PlusExp: (a:exp, b:exp)
      MinusExp: (a:exp, b:exp)
      NumExp: (value:int)
      FuncExp: (f:exp, args:tuple(exp))    

    defatom int (x:Int) :
      writer:
        put(out, x)
      reader:
        match(get-int(in)) :
          (x:Int) : x
          (f:False) : throw(DeserializeException())

    reader defn read-tuple<?T> (f: () -> ?T) :
      val n = read-int()
      to-tuple(repeatedly(f, n))

    writer defn write-tuple<?T> (f: T -> False, xs:Tuple<?T>) :
      write-int(length(xs))
      do(f, xs)

;============================================================
;=================== Testing Code ===========================
;============================================================

defn write-to-file (file:String, e:Exp) :
  val stream = FileOutputStream(file)
  try :
    val buffer = FastIOBuffer(4 * 1024, stream)
    try :
      write-exp(new ExpSerializer, buffer, e)
    finally :
      flush(buffer)
  finally :
    close(stream)

defn stz-write-to-file (file:String, e:Exp) :
  val t0 = current-time-us()
  val stream = FileOutputStream(file)
  try :
    serialize(stream, e)
  finally :
    close(stream)
  val t1 = current-time-us()
  println("Stz Done writing: %_ us" % [t1 - t0])

defn read-from-file (filename:String) -> Exp :
  val file = RandomAccessFile(filename, false)
  try :
    val len = to-int(length(file))
    println("%_ bytes" % [len])
    val buffer = FastIOBuffer(len + 8, fatal{"Readonly buffer."})
    val t0 = current-time-us()
    read-into-buffer(file, len, buffer)
    val t1 = current-time-us()
    val result = read-exp(new ExpSerializer, buffer)
    val t2 = current-time-us()
    ;println("Read into buffer: %_ us" % [t1 - t0])
    println("Parse Exp: %_ us" % [t2 - t0])
    println("Parse %_ bytes per second." % [to-long(len) * 1000L * 1000L / (t2 - t0)])
    result
  finally :
    close(file)

defn stz-read-from-file (filename:String) -> Exp :
  val t0 = current-time-us()
  val file = FileInputStream(filename)
  val result =
    try :
      deserialize-exp(file)
    finally :
      close(file)
  val t1 = current-time-us()
  println("Stz Done reading: %_ us" % [t1 - t0])
  result

lostanza defn read-into-buffer (file:ref<RandomAccessFile>, len:ref<Int>, buffer:ref<FastIOBuffer>) -> ref<False> :
  call-c clib/fread(buffer.data, 1, len.value, file.file)
  buffer.end = buffer.data + len.value
  return false

defn test-exp (n:Int) -> Exp :
  defn gen (n:Int) -> Exp :
    if n == 0 :
      NumExp(rand(100))
    else :
      switch(rand(4)) :
        0 : PlusExp(gen(n - 1), gen(n - 1))
        1 : MinusExp(gen(n - 1), gen(n - 1))
        2 : NumExp(rand(100))
        3 :
          val args = to-tuple $
            for i in 0 to rand(4) seq :
              gen(n - 1)
          FuncExp(gen(n - 1), args)
  gen(n)
    

defn main () :
  val n = to-int!(command-line-arguments()[1])
  srand(0L)
  println("Generating")
  val e = test-exp(n)
  println("Writing")
  val t0 = current-time-us()
  write-to-file("build/testout.dat", e)
  val t1 = current-time-us()
  println("Done Writing: %_ us" % [t1 - t0])
  println("Reading")
  val e2 = read-from-file("build/testout.dat")
  stz-write-to-file("build/testout2.dat", e)
  val e3 = stz-read-from-file("build/testout2.dat")
  false

main()