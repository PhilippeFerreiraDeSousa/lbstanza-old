defpackage stz/defs-db :
  import core
  import collections
  import stz/namemap
  import stz/compiler
  import stz/front-end
  import stz/visibility
  import stz/il-ir
  import stz/pkg
  import stz/dl-ir
  import stz/vm-ir
  import stz/algorithms
  import stz/proj-manager
  import stz/defs-db-serializer
  import stz/proj
  import stz/params
  import stz/config

;============================================================
;=================== Driver Arguments =======================
;============================================================
public defstruct DefsDbInput :
  proj-files: Tuple<String>
  platform: Symbol
  flags: Tuple<Symbol>
  optimize?: True|False
with : 
  printer => true

; Main entry point, given the input data and an output filename, 
; compile to IL-IR, create the definitions database, and serialize it 
; to the output file.
public defn defs-db (input:DefsDbInput, filename:String) :
  ; Compile the input 
  val [namemap, packages] = compile-input(input)

  ;Call generation of definitions database
  gen-defs-db(filename, namemap, packages)

; Helper function to compile the input data into IL-IR.
protected defn compile-input (input:DefsDbInput) -> [NameMap, Seqable<IPackage|Pkg>] :
  ;Read all listed packages from given project files
  val proj-file = read-proj-files(proj-files(input), platform(input))
  val input-packages = all-packages(proj-file)
  val proj-files-and-packages = to-tuple $
    cat(proj-files(input), input-packages)

  ; Compute the build settings (input to the compiler)
  val build-settings = BuildSettings(
    BuildPackages(proj-files-and-packages), ;inputs
    [],                                     ;vm-packages
    platform(input),                        ;platform
    false,                                  ;assembly
    false,                                  ;output
    false,                                  ;external dependencies
    false,                                  ;pkg-dir
    optimize?(input),                       ;optimize?
    [],                                     ;ccfiles
    [],                                     ;ccflags
    flags(input))                           ;flags
    
  ;Compute dependencies (compiles to IL-IR)
  val deps = dependencies(build-settings, true)

  ; return namemap and list of packages
  [namemap(deps), packages(deps)]

;==============================================================================
;========================= Main Indexing Algorithm ============================
;==============================================================================
; The `Indexed` struct is a helper that contains extracted metadata from IL-IR.
; before being associated with a package. 
;
;- kind:       The kind of originating expression (see SrcDefinitionKind)
;- visibility: The visibility of the expression (public|private|protected)
;- name:       The extracted name of the indexed expression
;- info:       The associated file info of the expression.
protected defstruct Indexed <: Equalable : 
  kind:SrcDefinitionKind
  visibility:Visibility
  name:Symbol
  info:FileInfo
  annotation?:False|DefinitionAnnotation
with : 
  printer => true

; An Indexable is an IExp that can be meaningfully indexed in the DefinitionsDatabase 
; structure. Currently supported are functions, multis, methods, types, and children
; in both Hi and Lo stanza.
deftype Indexable :  
  VarN         <: Indexable
  IDef         <: Indexable
  IDefn        <: Indexable
  IDefmulti    <: Indexable
  IDefmethod   <: Indexable
  IDefType     <: Indexable
  IDefChild    <: Indexable
  ILSDef       <: Indexable
  ILSDefn      <: Indexable
  ILSDefmethod <: Indexable
  ILSDefType   <: Indexable

; Depth first walk of the IL-IR to flatten into a sequence of `Indexed`, or 
; IExp nodes that have a meaningful name and FileInfo
;
; Input: The top level IExp nodes from IL-IR, and a NameMap to lookup associated
;        names of the nodes we will index.
;
; Output: A sequence of indexed expressions.
;
; Expected Behavior : 
; - When encountering an `IVisibility` node, traverse its child using that node's visibility
; - When encountering an `IBegin`, traverse its children with the current visibility.
; - The initial visibility is `Private`
; - If an expression is not `Indexable`, it is skipped
; - If an `Indexable` does not have an `info`, it is skipped
; - If an `Indexable`'s name cannot be found, it is skipped 
;
protected defn index-expressions (exps:Seqable<IExp>, nm:NameMap) -> Seq<Indexed> :
  generate<Indexed> : 
    defn loop (e:IExp, current-visibility:Visibility) :
      match(e) : 
        ; Case 1: We encounter a visibility node. Walk its
        ;         child with the new visibility.
        (v:IVisibility) : 
          loop(exp(v), visibility(v))
        ; Case 2: We encounter a `Begin` node. Walk its children
        ;         reusing the current visibility
        (b:IBegin) : 
          do(loop{_, current-visibility}, /exps(b))
        ; Case 3: We find an Indexable. Attempt to index it.
        (i:Indexable&IExp) : 
          val name = name?(i, nm)
          val info = info(i as IExp)
          val kind = kindof(i)
          val annotation? = annotate?(i, nm)
          ; Case 4a.: Successfully found info and name, yield
          ; Case 4b.: (implicit) If name or info is not found, skip.
          match(info:FileInfo, name:Symbol) : 
            yield(Indexed(kind, current-visibility, name, info, annotation?))
        ; Case 5: We encounter an IExp we can't index. Skip.
        (e:?) :
          false ; do nothing
    ; launch!
    do(loop{_, Private}, exps)

; Helper to extract definitions from DL-IR pulled out of .pkg and .fpkg files.
defn collect-definitions (packageio:PackageIO, nm:NameMap) -> Seq<Definition> :
  for e in filter({info(_) is-not False}, exports(packageio)) seq :
    Definition(name, info, kind, source, package, visibility, annotation?) where :
      val name        = name(id(rec(e)))
      val info        = info(e) as FileInfo
      val package     = package(packageio)
      val visibility  = visibility(e)
      val source      = PkgDefinition
      val kind        = kindof(rec(e))
      val annotation? = annotate?(e, nm)

; Helper multi to create an annotation for an indexable expression, if necessary.
defmulti annotate? (exp, nm:NameMap) -> False|DefinitionAnnotation : 
  false

defmethod annotate? (idefn:IDefn|IDefmethod|ILSDefn|ILSDefmethod, nm:NameMap) -> False|DefinitionAnnotation : 
  DefnAnnotation(args, return-type?) where :  
    val return-type? = stringify?(a2(idefn), nm)
    val args* = 
      for (arg in args(idefn), type in a1(idefn)) seq : 
        val arg-name = stringify?(arg, nm)
        val type-name = stringify?(type, nm)
        FnArgAnnotation(arg-name, type-name)
    val args = to-tuple(filter-by<FnArgAnnotation>(args*))

defmethod annotate? (export:Export, nm:NameMap) : 
  match(rec(export)) :
    (rec:FnRec|MultiRec) : 
      DefnAnnotation(args, return-type?) where : 
        val return-type? = stringify?(a2(rec), nm)
        val args = to-tuple $ 
          for (arg-type in a1(id(rec) as FnId), n in 0 to false) seq : 
            FnArgAnnotation(to-symbol("_%_" % [n]), stringify?(arg-type, nm))
    (r:?) :
      false

; A helper multi to handle the following cases : 
; - Indexing of source code
; - Indexing of .pkg files
; - Indexing of .fpkg files
protected defmulti index-definitions (pkg, nm:NameMap) -> Seq<Definition>

; Index a package from source code. First index the expressions, then convert to a `Definition`
; object that can be serialized.
defmethod index-definitions (ipackage:IPackage, nm:NameMap) -> Seq<Definition> :
  val indexed-exps = index-expressions(exps(ipackage), nm)
  for indexed in indexed-exps seq :  
    Definition(name, info, kind, source, package, visibility, annotation) where : 
      val package    = name(ipackage)
      val name       = name(indexed)
      val info       = info(indexed)
      val kind       = kind(indexed)
      val source     = SrcDefinition
      val visibility = visibility(indexed)
      val annotation = annotation?(indexed)

; Index a package from a .fpkg file.
defmethod index-definitions (pkg:FastPkg, nm:NameMap) -> Seq<Definition> :
  collect-definitions(packageio(pkg), nm)

; Index a package from a .pkg file.
defmethod index-definitions (pkg:StdPkg, nm:NameMap) -> Seq<Definition> :
  collect-definitions(packageio(vmp(pkg)), nm)

; Index a PackageDefinition from an IPackage node.  
protected defn index-package (ipackage:IPackage) -> PackageDefinition : 
  PackageDefinition(name, file-name, imports) where : 
    val name      = name(ipackage)
    val file-name = if-false?("NoFile", call?(filename, info(ipackage)))
    val imports   =
      for iimport in imports(ipackage) map :
        PackageImport(name, prefixes) where : 
          val name = package(iimport)
          val prefixes = 
            for iprefix in prefix(iimport) map : 
              PackageImportPrefix(names(iprefix), prefix(iprefix))

; A list of keywords in stanza.
val stanza-reserved-words = [
  "package" "import" "prefix-of" "prefix" "public" "protected" "private" "doc" "deftype" "defchild" "def"
  "defpackage" "defvar" "defn" "defn*" "defmulti" "defmethod" "defmethod*" "fn" "fn*"
  "multi" "begin" "let" "match" "branch" "new" "as" "as?" "set" "do"
  "prim" "tuple" "quote" "none" "of" "and" "or" "->" 
  "cap" "void" "new" "struct" "addr" "addr!" "deref"
  "slot" "field" "do" "call-c" "prim" "sizeof" "tagof" 
  "letexp" "and" "or" "set" "label" "labels" "block" "goto" "return"
  "let" "if" "match" "branch" "func" "def" "defvar" "deftype" "deffield"
  "extern" "extern-fn" "byte" "int" "long" "float" "double"
  "?" "of" "ptr" "ref"
  ]

; Create the definitions database by indexing definitions and packages
protected defn create-defs-db (name-map:NameMap, packages:Seqable<IPackage|Pkg|FastPkg>) -> DefinitionsDatabase : 
  val all-definitions = HashTable<Symbol, List<Definition>>(List())
  val all-packages = Vector<PackageDefinition>()
  
  for package in packages do :
    match(package:IPackage) : 
      add(all-packages, index-package(package))

    val definitions = index-definitions(package, name-map)
    for def in definitions do : 
      val name = name(def)
      update(all-definitions, cons{def, _}, name)
  
  DefinitionsDatabase(reserved-words, definitions, packages) where : 
    val reserved-words = stanza-reserved-words
    val definitions = all-definitions
    val packages = to-tuple(all-packages)

public defn gen-defs-db (out-path:String, 
                         name-map:NameMap,
                         packages:Seqable<IPackage|Pkg>) :
  val ostream = FileOutputStream(out-path)
  val defs = create-defs-db(name-map, packages)
  serialize(ostream, defs)
  close(ostream)

;==============================================================================
;================================ Helpers =====================================
;==============================================================================
; Report the "kind" of an IExp 
public defn kindof (e:IExp) : 
  match(e) : 
    (e:IDefmulti) : 
      SrcDefMulti
    (e:IDefmethod|ILSDefmethod) : 
      SrcDefMethod
    (e:IDefn|ILSDefn) : 
      SrcDefFunction
    (e:IDefType|ILSDefType) : 
      SrcDefType
    (e:?) : 
      SrcDefUnknown

public defn kindof (r:Rec) : 
  match(r) : 
    (v:ValRec|ExternRec)   : SrcDefVariable
    (f:FnRec|ExternFnRec)  : SrcDefFunction
    (m:MultiRec)           : SrcDefMulti
    (t:TypeRec|TypeDecl|StructRec) : SrcDefType
    (r:?) : SrcDefUnknown

; A helper multi that converts some IR that represents a named
; "thing" (type, identifier, etc) into human readable text.
defmulti stringify? (i, nm:NameMap) -> False|Symbol : 
  false

; Stringify types from lostanza types in pkg/fpkg files
defmethod stringify? (dtype:DByte, nm:NameMap)     : `byte
defmethod stringify? (dtype:DInt, nm:NameMap)      : `int
defmethod stringify? (dtype:DLong, nm:NameMap)     : `long
defmethod stringify? (dtype:DFloat, nm:NameMap)    : `float
defmethod stringify? (dtype:DDouble, nm:NameMap)   : `double
defmethod stringify? (dtype:DUnknown, nm:NameMap)  : `?

defmethod stringify? (dptr:DPtrT, nm:NameMap) : 
  to-symbol $ "ptr<%_>" % [stringify?(type(dptr), nm)]

defmethod stringify? (dfn:DFnT, nm:NameMap) : 
  to-symbol $ 
    match(r(t)) : 
      (f:False) : "fn (%,)" % [seq(stringify?{_, nm}, a(t))]
      (d:DType) : "fn (&,) -> %_" % [seq(stringify?{_, nm}, a(t)), r(t)]

defmethod stringify? (typeid:TypeId, nm:NameMap) :
  name(typeid)

defmethod stringify? (dtype:DOf, nm:NameMap) : 
  if empty?(targs(dtype)) : 
    name(id(dtype))
  else : 
    to-symbol $ "%_<%,>" % [name(id(dtype)), object-type(targs(dtype))]     
  
defmethod stringify? (dtype:DTVar, nm:NameMap) : 
  to-symbol $ "TV%_" % [index(dtype)]

defmethod stringify? (dtype:DCap, nm:NameMap) : 
  to-symbol $ "?%_" % [tvar(dtype)]

defmethod stringify? (dtype:DAnd, nm:NameMap) : 
  to-symbol $ string-join(seq(stringify?{_, nm}, types(dtype)), "&")

defmethod stringify? (dtype:DOr, nm:NameMap) : 
  to-symbol $ string-join(seq(stringify?{_, nm}, types(dtype)), "&")

defmethod stringify? (dtype:DTop, nm:NameMap) : 
  `top

defmethod stringify? (dtype:DBot, nm:NameMap) : 
  `bot

defmethod stringify? (dtype:DTuple, nm:NameMap) : 
  to-symbol $ "[%,]" % [types(dtype)]

defmethod stringify? (dtype:DArrow, nm:NameMap) : 
  to-symbol $ "(%,) -> %_" % [
    seq(stringify?{_, nm}, a1(dtype)), 
    stringify?(a2(dtype), nm)
  ]

defmethod stringify? (e:VarN, nm:NameMap) : 
  if key?(nm, n(e)) : 
    name(nm[n(e)])

defmethod stringify? (r:Raw, nm:NameMap) : 
  stringify?(class(r), nm)

defmethod stringify? (l:List, nm:NameMap) : 
  to-symbol("(%,)" % [seq(stringify?{_, nm}, l)])

defmethod stringify? (iof:IOf, nm:NameMap) : 
  to-symbol("%_<%,>" % [class(iof),  seq(stringify?{_, nm}, args(iof))])

defmethod stringify? (ior:IOr, nm:NameMap) : 
  val l = stringify?(a(ior), nm)
  val r = stringify?(b(ior), nm)
  match(l:Symbol, r:Symbol) :
    to-symbol("%_|%_" % [l, r])

defmethod stringify? (iand:IAnd, nm:NameMap) :
  val l = stringify?(a(iand), nm)
  val r = stringify?(b(iand), nm)
  match(l:Symbol, r:Symbol) :
    to-symbol("%_&%_" % [l, r])

defmethod stringify? (igrad:IGradual, nm:NameMap) :
  `? 

defmethod stringify? (inone:INone, nm:NameMap) :
  false

defmethod stringify? (iarrow:IArrow, nm:NameMap) : 
  val l = stringify?(a1(iarrow), nm)
  val r = stringify?(a2(iarrow), nm)
  match(l:Symbol, r:Symbol) :
    to-symbol("%_ -> %_" % [l, r])

defmethod stringify? (ivoid:IVoid, nm:NameMap) :
  `Void

defmethod stringify? (icap:ICap, nm:NameMap) : 
  val type = stringify?(name(icap), nm)
  match(type:Symbol) :
    to-symbol("?%_" % [type])

defmethod stringify? (ituple:ITuple, nm:NameMap) : 
  to-symbol("[%,]" % [seq(stringify?{_, nm}, exps(ituple))])

; Lookup the name of an Indexable from the name map.
defn name? (i:Indexable&IExp, nm:NameMap) -> False|Symbol :
  val exp-name =
    match(i) :
      (e:VarN) : e
      (e:IDef|ILSDef|ILSDefType|IDef|IDefVar|ILSDefn|IDefn|IDefmulti|IDefChild) : 
        name(e)
      (e:IDefType) : 
        class(e)
      (e:IDefmethod|ILSDefmethod) : 
        val name = multi(e)
        match(name:Mix) :
          head(exps(name))
        else : 
          name
  stringify?(exp-name, nm)

; call `f` if `x` is False, otherwise return false
defn call?<?T, ?U> (f: T -> ?U, x:?T|False) -> U|False : 
  false when x is False else f(x as T)

; return `value` if x is false, else return x
defn if-false?<?T> (value:?T, x:?T|False) -> T : 
  value when x is False else x as T

; Index entries are `Equalable` for testing.
defmethod equal? (l:Indexed, r:Indexed) :
  kind(l) == kind(r) and 
  visibility(l) == visibility(r) and 
  name(l) == name(r) and 
  info(l) == info(r)

;============================================================
;============= Retrieve All Packages in Proj File ===========
;============================================================
defn all-packages (proj-file:ProjFile) -> Tuple<Symbol> :
  val defined = filter-by<DefinedInStmt>(stmts(proj-file))
  to-tuple(seq(package, defined))
 