defpackage stz/proj-wellformedness :
  import core
  import collections
  import stz/params
  import stz/proj-ir
  import stz/proj-env
  import stz/proj-stage0
  import stz/proj-errors
  import stz/utils

;============================================================
;========================= API ==============================
;============================================================

public deftype ProjWellformedness

;Check the given file, and make any required preprocessing/modifications.
public defmulti check (wf:ProjWellformedness, f:ProjFileS0) -> ProjFileS0

;============================================================
;=========== General Wellformedness Algorithm ===============
;============================================================

public defn ProjWellformedness (platform:Symbol,
                                env:ProjEnv) -> ProjWellformedness :
                                
  ;Create table of package manager info.
  val package-manager-table = to-hashtable(name, foreign-package-managers(env))

  new ProjWellformedness :
    defmethod check (this, f:ProjFileS0) :
      ;Create a vector to hold any detected errors.
      val errors = Vector<ProjFileError>()

      ;Check for wellformedness and duplicates.
      val f* = check-wellformed(f, platform, package-manager-table, errors)
      check-duplicates(f*, errors)

      ;Throw errors if there is any.
      throw-proj-file-errors?(errors)

      ;Return new preprocessed file.
      f*

;============================================================
;============== Wellformedness of each Statement ============
;============================================================

;Checks a single item for wellformedness errors.
;Recursing into subitems are handled by the caller.
defmulti check-item-wellformed (x:ProjItem,
                                platform:Symbol,
                                pmtable:HashTable<Symbol,ForeignPackageManagerInfo>,
                                errors:Vector<ProjFileError>) -> ProjItem :
  x

;Included files must end with .proj.
defmethod check-item-wellformed (x:IncludeStmtS0,
                                 platform:Symbol,
                                 pmtable:HashTable<Symbol,ForeignPackageManagerInfo>,
                                 errors:Vector<ProjFileError>) :
  if not suffix?(path(x), ".proj") :
    val msg = "Expected a .proj file here, but found %_." % [path(x)]
    add(errors, ProjFileError(info(x), to-string(msg)))
    
  ;Return unchanged.
  x

;Check whether the platforms are properly handled.
defmethod check-item-wellformed (x:CondPlatform,
                                 platform:Symbol,
                                 pmtable:HashTable<Symbol,ForeignPackageManagerInfo>,
                                 errors:Vector<ProjFileError>) :
  ;Check whether all the platforms are either supported platforms, or
  ;the 'else' keyword.
  val n = length(values(x))
  for (entry in values(x), i in 0 to false) do :
    if key(entry) == `else :
      if i != n - 1 :
        val msg = "The 'else' keyword can only be used as last entry in list."
        add(errors, ProjFileError(info(x), msg))
    else :
      if not supported-platform?(key(entry)) :
        val msg = "'%~' does not refer to a supported platform." % [key(entry)]
        add(errors, ProjFileError(info(x), to-string(msg)))

  ;Check whether the current platform is one of the supported options.
  val current-platform-supported? =
    for entry in values(x) any? :
      key(entry) == `else or
      key(entry) == platform

  ;Issue error if current platform is not supported.
  if not current-platform-supported? :
    val msg = "There is no available option for the current platform '%~'." % [platform]
    add(errors, ProjFileError(info(x), to-string(msg)))

  ;Return unchanged.
  x

defmethod check-item-wellformed (x:ForeignPackageParamsStmtS0,
                                 platform:Symbol,
                                 pmtable:HashTable<Symbol,ForeignPackageManagerInfo>,
                                 errors:Vector<ProjFileError>) :
  ;Helper: Wrap a ProjValue in the right type depending on context.
  defn wrap-in-context (v:ProjValue, ctxt:FieldContext) -> ProjValue :
    switch(ctxt) :
      PathField : FilePath(info(v), v)
      CommandField : wrap-command-strings(v)
      StandardField : v
      
  ;Look for the corresponding info from the package manager.
  match(get?(pmtable, package-manager(x))) :
    (pminfo:ForeignPackageManagerInfo) :
      ;Create tables for the both cases.
      val param-set = to-hashtable(field-name, params(pminfo))
      val entry-set = HashTable<Symbol,ProjValue>()
      
      ;Check for duplicate entries, and unsupported entries, while
      ;populating entry-set.
      for entry in entries(x) do :
        if key?(entry-set, key(entry)) :
          val msg = "There is a duplicate entry for the '%~' parameter." % [key(entry)]
          add(errors, ProjFileError(info(x), to-string(msg)))
        else if not key?(param-set, key(entry)) :
          val msg = "The '%~' parameter is not a recognized parameter for the %_ \
                     package manager." % [key(entry), package-manager(x)]
          add(errors, ProjFileError(info(x), to-string(msg)))          
        else :
          val param = param-set[key(entry)]
          entry-set[key(entry)] = wrap-in-context(value(entry), field-context(param))

      ;Ensure that all required parameters are provided.
      for param in params(pminfo) do :
        if not optional?(param) :
          if not key?(entry-set, field-name(param)) :
            val msg = "The '%~' parameter is a required parameter for the %_ \
                       package manager, but it is not provided." % [field-name(param), package-manager(x)]
            add(errors, ProjFileError(info(x), to-string(msg)))
            
      ;Return the new preprocessed statement.
      sub-entries(x, to-tuple(entry-set))      

    (f:False) :
      val msg = "The package manager '%~' is not one of the supported \
                 external package managers." % [package-manager(x)]
      add(errors, ProjFileError(info(x), to-string(msg)))
      x

;============================================================
;============= Welformedness of Whole File ==================
;============================================================

;Check the given item for wellformedness.
defn check-wellformed (f:ProjFileS0,
                       platform:Symbol,
                       pmtable:HashTable<Symbol,ForeignPackageManagerInfo>,
                       errors:Vector<ProjFileError>) -> ProjFileS0 :
  defn check-item (x:ProjItem) :
    val x* = map(check-item, x)
    check-item-wellformed(x*, platform, pmtable, errors)
  val new-stmts = map(check-item, stmts(f))
  sub-stmts(f, new-stmts as Tuple<ProjStmt>)

;============================================================
;================= Check for Duplicates =====================
;============================================================

;Check for duplicate statements in the same file.
defn check-duplicates (f:ProjFileS0, errors:Vector<ProjFileError>) -> False :
  val groups = group-by(duplication-key, stmts(f))
  for group in groups do :
    if key(group) is-not False :
      if length(value(group)) > 1 :
        val stmts = reverse(value(group))
        val stmt0 = head(stmts)
        for stmt in tail(stmts) do :
          add(errors, DuplicateStmt(info(stmt), stmt-description(stmt), info(stmt0)))