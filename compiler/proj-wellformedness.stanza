defpackage stz/proj-wellformedness :
  import core
  import collections
  import stz/params
  import stz/proj-stage0
  import stz/proj-errors
  import stz/utils

;Issues an error if:
;- CondPlatform expressions are not wellformed.
;- Duplicate statements exist.

public defn ensure-wellformed (f:ProjFileS0, platform:Symbol) -> ProjFileS0 :
  val errors = Vector<ProjFileError>()
  defn emit-error (e:ProjFileError) : add(errors, e)

  defn ensure-suffix! (info:FileInfo|False, path:String, suffix:String) :
    if not suffix?(path, suffix) :
      val msg = "Expected a %_ file here, but found %~." % [suffix path]
      emit-error $ ProjFileError(info, to-string(msg))

  defn ensure-wellformed (v:Maybe<ProjValue>) :
    ensure-wellformed(value!(v)) when not empty?(v)

  defn ensure-wellformed (v:ProjValue) :
    ;Check whether platforms are supported in value
    defn check-platforms (v:ProjValue) :
      match(v) :
        (v:AtomValue) :
          false
        (v:ProjValues) :
          do(check-platforms, values(v))
        (v:CondPlatform) :
          ;First check keys are supported platforms or 'else'.
          val n = length(values(v))
          for (entry in values(v), i in 0 to false) do :
            if key(entry) == `else :
              if i != n - 1 :
                emit-error $ ProjFileError(info(v), "The 'else' keyword can only be used as last entry in list.")
            else :
              if not supported-platform?(key(entry)) :
                emit-error $ ProjFileError(info(v), to-string("'%~' does not refer to a supported platform." % [key(entry)]))
          ;Check whether given platform is supported.
          val platform-supported? =
            for entry in values(v) any? :
              key(entry) == `else or key(entry) == platform
          if not platform-supported? :
            emit-error $ ProjFileError(info(v), to-string("There is no available option for the current platform %~." % [platform]))
          ;Then recurse
          do(check-platforms{value(_)}, values(v))
        (v:VarValue) :
          false

    ;Launch!
    check-platforms(v)

  defn ensure-no-duplicates<?T> (error:(T, T) -> ProjFileError, key:T -> ?, stmts:Seqable<?T>) :
    for group in group-by(key, stmts) do :
      if length(value(group)) > 1 :
        val vs = reverse(value(group))
        val v0 = head(vs)
        for v in tail(vs) do :
          emit-error(error(v0, v))

  ;Scan through statements
  for s in stmts(f) do :
    match(s) :
      (s:IncludeStmtS0) : ensure-suffix!(info(s), path(s), ".proj")
      (s:DefinedInStmtS0) : ensure-wellformed(filename(s))
      (s:PackagesDefinedInStmtS0) : ensure-wellformed(filename(s))
      (s:SyntaxPackagesDefinedInStmtS0) : ensure-wellformed(filename(s))
      (s:RequiresStmtS0) : do(ensure-wellformed, [ccfiles(s), ccflags(s)])
      (s:ImportWhenStmtS0) : ensure-wellformed(dependencies(s))
      (s:CompileStmtS0) : do(ensure-wellformed, [name-value(s), dependencies(s), commands(s)])
      (s:BuildStmtS0) : do(ensure-wellformed, [inputs(s), supported-vm-packages(s), pkg(s),
                                               output(s), assembly(s), external-dependencies(s), ccfiles(s), ccflags(s)])
      (s:VarStmtS0) : ensure-wellformed(value(s))

  ;Check for duplicate statements
  within (s0,s1) = ensure-no-duplicates(path, filter-by<IncludeStmtS0>(stmts(f))) :
    ProjFileError(info(s1), to-string $ "Duplicate include statement for file %~. Earlier statement at %_." % [
      path(s1), info(s0)])
  within (s0,s1) = ensure-no-duplicates(package, filter-by<DefinedInStmtS0>(stmts(f))) :
    ProjFileError(info(s1), to-string $ "Duplicate defined-in statement for package %_. Earlier statement at %_." % [
      package(s1), info(s0)])
  within (s0,s1) = ensure-no-duplicates(packages, filter-by<PackagesDefinedInStmtS0>(stmts(f))) :
    ProjFileError(info(s1), to-string $ "Duplicate defined-in statement for packages %_. Earlier statement at %_." % [
      packages(s1), info(s0)])
  within (s0,s1) = ensure-no-duplicates(packages, filter-by<SyntaxPackagesDefinedInStmtS0>(stmts(f))) :
    ProjFileError(info(s1), to-string $ "Duplicate defined-in statement for syntax packages %_. Earlier statement at %_." % [
      packages(s1), info(s0)])
  within (s0,s1) = ensure-no-duplicates(package, filter-by<RequiresStmtS0>(stmts(f))) :
    ProjFileError(info(s1), to-string $ "Duplicate requires statement for package %_. Earlier statement at %_." % [
      package(s1), info(s0)])
  within (s0,s1) = ensure-no-duplicates(name, filter-by<CompileStmtS0>(stmts(f))) :
    ProjFileError(info(s1), to-string $ "Duplicate compile statement for file %~. Earlier statement at %_." % [
      name(s1), info(s0)])
  within (s0,s1) = ensure-no-duplicates(name, filter-by<BuildStmtS0>(stmts(f))) :
    ProjFileError(info(s1), to-string $ "Duplicate build definition for target %~. Earlier definition at %_." % [
      name(s1), info(s0)])

  ;Throw exception if any errors
  throw-proj-file-errors?(errors)
  ;Return file unchanged
  f