defpackage stz/proj-normalization :
  import core
  import collections
  import stz/proj-ir
  import stz/proj-stage0
  import stz/proj-errors
  import core/parsed-path

;This pass normalizes all ProjValue within the proj file.
;- Collapses all CondPlatform values into a single value.
;- Separates SplicedString values that contain ProjValues.
;- Guarantees that ProjValues do not recursively contain ProjValues.

public defn normalize (f:ProjFileS0, current-platform:Symbol) -> ProjFileS0 :
  val dirtable = SpecialDirTable(f)
  defn norm (item:ProjItem) -> ProjItem :
    match(item:ProjValue) : normalize(item, current-platform, dirtable)
    else : map(norm, item)
  val new-stmts = map({norm(_) as ProjStmt}, stmts(f))
  sub-stmts(f, new-stmts)

;============================================================
;=================== Value Normalization ====================
;============================================================

;Normalize the given value under the given platform.
;- Collapses all CondPlatform values into a single value.
;- Separates SplicedString values that contain ProjValues.
;- Guarantees that ProjValues do not recursively contain ProjValues.

defn normalize (v:ProjValue,
                platform:Symbol,
                dirtable:SpecialDirTable) -> ProjValue :
  v $> eval-condplatform{_, platform}
    $> separate-spliced-strings
    $> flatten-projvalues
    $> substitute-special-dirs{_, dirtable}

;============================================================
;================ Evaluate CondPlatform =====================
;============================================================

;Evaluate all CondPlatform in the given ProjValue.
defn eval-condplatform (v:ProjValue, platform:Symbol) -> ProjValue :
  match(v:CondPlatform) :
    for e in values(v) first! :
      if key(e) == platform or key(e) == `else :
        One(eval-condplatform(value(e), platform))
      else :
        None()
  else :
    val result = map(eval-condplatform{_ as ProjValue, platform}, v)
    result as ProjValue

;============================================================
;=============== Separating SplicedString ===================
;============================================================

;If a SplicedString contains a ProjValues, then treat the
;values as if they contain a separator, and hence splits up the
;overall string into multiple separate values.
;The input SplicedString assumes that values contain no CondPlatform.

defn separate-spliced-strings (v:ProjValue) -> ProjValue :
  val result = map(separate-spliced-strings{_ as ProjValue}, v)
  match(result) :
    (result:SplicedString) :
      separate-spliced-string(result)
    (result:ProjValue) :
      result

defn separate-spliced-string (spliced-string:SplicedString) -> ProjValue :
  ;Create buffer of values and separators
  val buffer = Vector<ProjValue|Separator>()

  ;Iterate through the values and add them to the buffer with
  ;a separator between ProjValues.
  for value in values(spliced-string) do :
    let loop (value:ProjValue = value) :
      match(value) :
        (value:ProjValues) :
          for (v in values(value), i in 0 to false) do :
            add(buffer, Separator()) when i > 0
            loop(v)
        (value:SplicedString) :
          add-all(buffer, values(value))
        (value) :
          add(buffer, value)

  ;Identify all the continuous chains of values between the
  ;separators.
  defn continuous-chains () -> Seqable<Range> :
    generate<Range> :
      var start:Int = 0
      for (v in buffer, i in 0 to false) do :
        match(v:Separator) :
          yield(start to i)
          start = i + 1
      yield(start to length(buffer))

  ;For all the continuous chains of values that do not
  ;contain a Separator, join them into one SplicedString.
  val joined-values = to-tuple $
    for r in continuous-chains() seq :
      if length(r as Range&Lengthable) == 1 :
        buffer[start(r)] as ProjValue
      else :
        val vs = for i in r seq : buffer[i] as ProjValue
        SplicedString(info(spliced-string), to-tuple(vs))

  ;Return either a single value or ProjValues.
  if length(joined-values) == 1 : joined-values[0]
  else : ProjValues(info(spliced-string), joined-values)

;Dummy object for separating chains of values.
defstruct Separator

;============================================================
;=================== Flatten ProjValues =====================
;============================================================

;Flatten every ProjValues. We guarantee after this that:
;- ProjValues never recursively contains another ProjValues.
;- ProjValues never have length 1.

defn flatten-projvalues (v:ProjValue) -> ProjValue :
  match(v:ProjValues) :
    val vs = to-tuple $
      for vi in values(v) seq-cat :
        match(flatten-projvalues(vi)) :
          (vi:ProjValues) : values(vi)
          (v) : [v]
    if length(vs) == 1 : vs[0]
    else : ProjValues(info(v), vs)
  else :
    map(flatten-projvalues{_ as ProjValue}, v) as ProjValue

;============================================================
;================ Substitute Special Dirs ===================
;============================================================

;Hold all the paths needed to resolve WorkDir and ProjDir.
defstruct SpecialDirTable :
  workdir:String
  projdirs:IntTable<String>

;Scan the file for the mapping from file ids to paths.
defn SpecialDirTable (file:ProjFileS0) -> SpecialDirTable :
  ;Get the current working directory.
  val workdir = resolve-path!(".")

  ;Create the table of project directories.
  val projdirs = IntTable<String>()

  ;Add a new project directory to the table.
  defn add-proj-dir (id:Int, proj-path:String) :
    projdirs[id] = to-string(enclosing-dir(proj-path))

  ;Scan a statement and add entries to prodirs.
  defn scan (stmt:ProjStmt) :
    match(stmt:IncludedStmtsS0) :
      add-proj-dir(proj-file-id(stmt), full-path(stmt))
      do(scan, stmts(stmt))

  ;Launch!
  add-proj-dir(id(file), full-path(file))
  do(scan, stmts(file))

  ;Bundle up the SpecialDirTable.
  SpecialDirTable(workdir, projdirs)

;Substitute all the WorkDir|ProjDir values in the ProjValue.
;Convert all SplicedString into AtomValue.
defn substitute-special-dirs (v:ProjValue,
                              dirtable:SpecialDirTable) -> ProjValue :
  match(v) :
    (v:WorkDir) :
      AtomValue(info(v), workdir(dirtable))
    (v:ProjDir) :
      AtomValue(info(v), projdirs(dirtable)[proj-file-id(v)])
    (v:SplicedString) :
      val new-values = for vi in values(v) map :
        substitute-special-dirs(vi, dirtable) as AtomValue
      val string = string-join(seq(value, new-values))
      AtomValue(info(v), string)
    (v:ProjValue) :
      map(substitute-special-dirs{_ as ProjValue, dirtable}, v)
