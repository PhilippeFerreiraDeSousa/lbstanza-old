defpackage stz/proj-stage0 :
  import core
  import collections
  import stz/proj-ir

;============================================================
;==================== Stage0 IR =============================
;============================================================

public defstruct ProjFileS0 :
  path: String
  full-path: String
  stmts: Tuple<ProjStmt>

;Attach a fileinfo to every ProjStmt.
public defmulti info (s:ProjStmt) -> FileInfo|False

public defstruct IncludeStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  path: String
with: (printer => true)

public defstruct IncludedStmtsS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  path: String
  full-path: String
  stmts: Tuple<ProjStmt>

public defstruct DefinedInStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  package: Symbol
  filename: ProjValue
with: (printer => true)

public defstruct PackagesDefinedInStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  packages: Symbol
  filename: ProjValue
with: (printer => true)

public defstruct RequiresStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  package: Symbol
  ccfiles: Maybe<ProjValue>
  ccflags: Maybe<ProjValue>
with: (printer => true)

public defstruct ImportWhenStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  package: Symbol
  dependencies: ProjValue
with: (printer => true)

public defstruct CompileStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  file?: True|False
  name: String
  name-value: ProjValue
  dependencies: Maybe<ProjValue>
  commands: ProjValue
with: (printer => true)

public defstruct BuildStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  name: Symbol
  type: BuildTargetType
  inputs: ProjValue
  supported-vm-packages: Maybe<ProjValue>
  pkg: Maybe<ProjValue>
  output: Maybe<ProjValue>
  assembly: Maybe<ProjValue>
  external-dependencies: Maybe<ProjValue>
  ccfiles: Maybe<ProjValue>
  ccflags: Maybe<ProjValue>
  flags: Maybe<ProjValue>
  optimize: True|False
with: (printer => true)

;Example:
;  syntax-packages (core jitx) defined-in "jitx-macros.so"
public defstruct SyntaxPackagesDefinedInStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  packages: Tuple<Symbol>
  filename: ProjValue
with: (printer => true)

public defstruct VarStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  name: Symbol
  value: ProjValue

;============================================================
;===================== Values ===============================
;============================================================

;Represents a structured value that is read within
;a .proj file.
public deftype ProjValue
public defmulti info (s:ProjValue) -> FileInfo|False
public defmulti sub-info (s:ProjValue, info:FileInfo|False) -> ProjValue

;------------------------------------------------------------
;-------------------- Values from Reader --------------------
;------------------------------------------------------------

;Represents either a string or a symbol.
;Example:
;  "-myflag"
public defstruct AtomValue <: ProjValue :
  info: FileInfo|False with: (as-method => true, updater => sub-info)
  value: String|Symbol
with: (printer => true)

;Represents a value that is conditional on the
;system platform. 
;Example:
;  on-platform :
;    os-x : something
;    windows : something-else
public defstruct CondPlatform <: ProjValue :
  info: FileInfo|False with: (as-method => true, updater => sub-info)
  values: Tuple<KeyValue<Symbol,ProjValue>>
with: (printer => true)

;Represents a reference to a defined variable.
;Example:
;  {MYVAR}
public defstruct VarValue <: ProjValue :
  info: FileInfo|False with: (as-method => true, updater => sub-info)
  name: Symbol
with: (printer => true)

;Represents multiple values wrapped in a list.
;Example:
;  (a b c d)
public defstruct ProjValues <: ProjValue :
  info: FileInfo|False with: (as-method => true, updater => sub-info)
  values: Tuple<ProjValue>
with: (printer => true)

;------------------------------------------------------------
;------------- Values Introduced During Processing ----------
;------------------------------------------------------------

public defstruct SplicedString <: ProjValue :
  info: FileInfo|False with: (as-method => true, updater => sub-info)
  values: Tuple<ProjValue>
with: (printer => true)

public defstruct CommandString <: ProjValue :
  info: FileInfo|False with: (as-method => true, updater => sub-info)
  value: ProjValue
public defstruct ProjDir <: ProjValue :
  info: FileInfo|False with: (as-method => true, updater => sub-info)
with: (printer => true)

public defstruct WorkDir <: ProjValue :
  info: FileInfo|False with: (as-method => true, updater => sub-info)
with: (printer => true)

;============================================================
;====================== Printer =============================
;============================================================

defmethod print (o:OutputStream, f:ProjFileS0) :
  print(o, "ProjFileS0:")
  val o2 = IndentedStream(o)
  lnprint(o2, "path: %~" % [path(f)])
  lnprint(o2, "full-path: %~" % [full-path(f)])
  do(lnprint{o2, _}, stmts(f))

defmethod print (o:OutputStream, s:IncludedStmtsS0) :
  print(o, "IncludedStmtsS0:")
  val o2 = IndentedStream(o)
  lnprint(o2, "info: %~" % [info(s)])
  lnprint(o2, "path: %~" % [path(s)])
  lnprint(o2, "full-path: %~" % [full-path(s)])
  do(lnprint{o2, _}, stmts(s))

;============================================================
;================== Mappers and Doers =======================
;============================================================

public deftype ProjItem :
  ProjValue <: ProjItem
  ProjStmt <: ProjItem

;Generalized mapper for all ProjItem.
public defn map (f:ProjItem -> ProjItem, x:ProjItem) -> ProjItem :
  ;Type-specific applicators for 'f'.
  defn h (x:ProjStmt) : f(x) as ProjStmt
  defn h (x:ProjValue) : f(x) as ProjValue
  defn h (x:Tuple<ProjStmt>) : map(h,x)
  defn h (x:Tuple<ProjValue>) : map(h,x)  
  defn h (x:Maybe<ProjValue>) :
    None() when empty?(x) else One(h(value!(x)))
  defn h (x:Tuple<KeyValue<Symbol,ProjValue>>) : 
    for e in x map :
      key(e) => h(value(e))
  ;Dispatch based upon the type of ProjItem.
  match(x) :
    (x:IncludeStmtS0) : x
    (x:IncludedStmtsS0) : IncludedStmtsS0(info(x), path(x), full-path(x), h(stmts(x)))
    (x:DefinedInStmtS0) : DefinedInStmtS0(info(x), package(x), h(filename(x)))
    (x:PackagesDefinedInStmtS0) : PackagesDefinedInStmtS0(info(x), packages(x), h(filename(x)))
    (x:RequiresStmtS0) : RequiresStmtS0(info(x), package(x), h(ccfiles(x)), h(ccflags(x)))
    (x:ImportWhenStmtS0) : ImportWhenStmtS0(info(x), package(x), h(dependencies(x)))
    (x:CompileStmtS0) : CompileStmtS0(info(x), file?(x), name(x), h(name-value(x)),
                                      h(dependencies(x)), h(commands(x)))
    (x:BuildStmtS0) : BuildStmtS0(info(x), name(x), type(x), h(inputs(x)), h(supported-vm-packages(x)),
                                  h(pkg(x)), h(output(x)), h(assembly(x)), h(external-dependencies(x)),
                                  h(ccfiles(x)), h(ccflags(x)), h(flags(x)), optimize(x))
    (x:SyntaxPackagesDefinedInStmtS0) : SyntaxPackagesDefinedInStmtS0(info(x), packages(x), h(filename(x)))
    (x:VarStmtS0) : VarStmtS0(info(x), name(x), h(value(x)))
    (x:AtomValue) : x
    (x:CondPlatform) : CondPlatform(info(x), h(values(x)))
    (x:VarValue) : x
    (x:ProjValues) : ProjValues(info(x), h(values(x)))
    (x:SplicedString) : SplicedString(info(x), h(values(x))) 
    (x:CommandString) : CommandString(info(x), h(value(x)))
    (x:ProjDir) : x
    (x:WorkDir) : x

;Generalized doer for all ProjItem.
public defn do (f:ProjItem -> ?, x:ProjItem) -> False :
  defn h (x:ProjItem) : (f(x), x)
  map(h,x)
  false