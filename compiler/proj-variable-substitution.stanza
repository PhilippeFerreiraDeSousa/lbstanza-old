defpackage stz/proj-variable-substitution :
  import core
  import collections
  import stz/proj-ir
  import stz/proj-stage0
  import stz/proj-errors

public defn variable-substitution (f:ProjFileS0) :
  ;Compute values of all symbols
  val symbol-table = HashTable<Symbol,ProjValue>()

  ;Accumulate errors
  val errors = Vector<ProjFileError>()

  ;Retrieve a value from the symbol table
  defn get-value! (info:FileInfo|False, name:Symbol) -> ProjValue :
    if not key?(symbol-table, name) :
      val env-v = get-env(to-string(name))
      match(env-v:String) :
        AtomValue(info, env-v)
      else :
        ;Record error
        add(errors, ProjFileError(info, to-string("Cannot resolve variable %_." % [name])))
        ;Return dummy
        VarValue(info, name)
    else :
      sub-info(symbol-table[name], info)
  defn get-value! (info:FileInfo|False, name:String) :
    get-value!(info, to-symbol(name))

  ;Substitute variables into given string
  defn sub-string-vars (info:FileInfo|False, s:String) -> ProjValue :
    within name = sub-curly(info, s) :
      if name == "." : ProjDir(info)
      else if name == "WORKDIR" : WorkDir(info)
      else : get-value!(info,name)

  ;Substitute variables into value
  defn sub-vars (v:ProjValue) -> ProjValue :
    match(v) :
      (v:AtomValue) :
        match(value(v)) :
          (value:String) : sub-string-vars(info(v), value)
          (value:Symbol) : v
      (v:ProjValues) :
        ProjValues(info(v), map(sub-vars, values(v)))
      (v:CondPlatform) :
        CondPlatform(info(v), map-values(sub-vars, values(v)))
      (v:VarValue) :
        get-value!(info(v),name(v))
      (v:CommandString) :
        CommandString(info(v), sub-vars(value(v)))

  ;Wrap command strings
  defn wrap-command-strings (v:ProjValue) -> ProjValue :
    match(v) :
      (v:AtomValue) :
        CommandString(info(v), v)
      (v:ProjValues) :
        ProjValues(info(v), map(wrap-command-strings, values(v)))
      (v:CondPlatform) :
        CondPlatform(info(v), map-values(wrap-command-strings, values(v)))
      (v:VarValue) :
        v

  ;Substitute all variables
  defn sub-vars (s:ProjStmt) -> ProjStmt :
    match(s) :
      (s:IncludedStmtsS0) :
        IncludedStmtsS0(
          info(s),
          path(s),
          full-path(s),
          map(sub-vars, stmts(s)))
      (s:DefinedInStmtS0) :
        DefinedInStmtS0(
          info(s),
          package(s),
          sub-vars(filename(s)))
      (s:PackagesDefinedInStmtS0) :
        PackagesDefinedInStmtS0(
          info(s),
          packages(s),
          sub-vars(filename(s)))
      (s:SyntaxPackagesDefinedInStmtS0) :
        SyntaxPackagesDefinedInStmtS0(
          info(s),
          packages(s),
          sub-vars(filename(s)))
      (s:RequiresStmtS0) :
        RequiresStmtS0(
          info(s),
          package(s),
          maybe?(sub-vars, ccfiles(s)),
          maybe?(sub-vars, ccflags(s)))
      (s:ImportWhenStmtS0) :
        ImportWhenStmtS0(
          info(s),
          package(s),
          sub-vars(dependencies(s)))
      (s:CompileStmtS0) :
        CompileStmtS0(
          info(s)
          file?(s)
          name(s)
          sub-vars(name-value(s)),
          maybe?(sub-vars, dependencies(s))
          sub-vars(wrap-command-strings(commands(s))))
      (s:BuildStmtS0) :
        BuildStmtS0(
          info(s)
          name(s)
          type(s)
          sub-vars(inputs(s))
          maybe?(sub-vars, supported-vm-packages(s))
          maybe?(sub-vars, pkg(s))
          maybe?(sub-vars, output(s))
          maybe?(sub-vars, assembly(s))
          maybe?(sub-vars, external-dependencies(s))
          maybe?(sub-vars, ccfiles(s))
          maybe?(sub-vars, ccflags(s))
          maybe?(sub-vars, flags(s))
          optimize(s))
      (s:VarStmtS0) :
        val value* = sub-vars(value(s))
        symbol-table[name(s)] = value*
        VarStmtS0(info(s), name(s), value*)

  ;Launch!
  val stmts* = map(sub-vars,stmts(f))

  ;Check for errors
  throw(ProjFileErrors(errors)) when not empty?(errors)

  ;Return substituted Project File
  ProjFileS0(path(f), full-path(f), stmts*)


defn sub-curly (f:String -> ProjValue, info:FileInfo|False, s:String) -> ProjValue :
  if index-of-char(s, '{') is False :
    AtomValue(info, s)
  else :
    val buffer = Vector<ProjValue>()

    ;Iterate through the curlies
    let loop (start:Int = 0) :
      ;Determine curly bounds
      val [i, j] = let :
        val i = index-of-char(s, start to false, '{')
        match(i:Int) :
          [i, index-of-char(s, (i + 1) to false, '}')]
        else : [i, false]
      ;If there is a curly
      match(i:Int, j:Int) :
        ;Add string up to curly
        if start < i :
          add(buffer, AtomValue(info, s[start to i]))
        ;Add replacement
        val replacement = f(s[(i + 1) through (j - 1)])
        add(buffer, replacement)
        ;Continue past } char
        loop(j + 1)
      else :
        ;End of string, add the rest
        if start < length(s) :
          add(buffer, AtomValue(info, s[start to false]))

    ;Return spliced string
    SplicedString(info, to-tuple(buffer))

;============================================================
;======================== Utilities =========================
;============================================================

defn maybe?<?T,?S> (f:T -> ?S, x:Maybe<?T>) -> Maybe<S> :
  if empty?(x) : None()
  else : One(f(value!(x)))

defn tuple?<?T,?S> (f:T -> Tuple<?S>, x:Maybe<?T>) -> Tuple<S> :
  if empty?(x) : []
  else : f(value!(x))

defn map-values<?K,?V1,?V2> (f:V1 -> ?V2, xs:Tuple<KeyValue<?K,?V1>>) :
  for x in xs map : key(x) => f(value(x))