defpackage stz/fastio-serializer-lang-parser :
  import core
  import collections
  import stz/fastio-serializer-lang
  import stz/core-macros
  import stz/fastio-errors

within (package,sig) = set-stack-trace-filter() :
  package != `core

;============================================================
;==================== Syntax Definition =====================
;============================================================

defsyntax fastio-serializer-lang :
  import (id!, exp!, type!, type$, :!, id) from core

  public defproduction defserializer: DefSerializer
  defrule defserializer = (defserializer ?name:#id! #:! (
                             ?entry-points:#entry-points!
                             ?exps:#texp! ...)) :
    DefSerializer(closest-info(),
                  unwrap-token(name),
                  entry-points,
                  to-tuple(exps))

  ;Read the entry points for the overall defserializer.
  defproduction entry-points!: Tuple<Symbol>
  defrule entry-points! = (entry-points #:! (?names:#id! ...)) :
    to-tuple(unwrap-all(names))
  fail-if entry-points! = () :
    FSE(closest-info(), "Expected listing of serializer entry points here.")

  ;----------------------------------------------------------
  ;------------------- Top Level Expressions ----------------
  ;----------------------------------------------------------

  defproduction texp!:TopExp

  ;Syntax for 'include'
  defrule texp! = (include ?filename:#string) :
    match(closest-info()) :
      (info:FileInfo) : IncludeFile(info, unwrap-token(filename))
      (f:False) : throw(FSE(false, "Include statement is not supported if \
                                    name of current file is unknown."))

  ;Syntax for 'defatom'
  defrule texp! = (defatom ?name:#id! (?binder:#id! #:! ?type:#type$) #:! (
                     #writer! #:! (?writer-exps ...)
                     #reader! #:! (?reader-exps ...))) :
    DefAtom(closest-info(),
            unwrap-token(name),
            unwrap-token(binder),
            type,
            writer-exps,
            reader-exps)

  ;Syntax for 'defunion'
  defrule texp! = (defunion ?name:#id! (?type:#type$) #:! (
                     ?branches:#ubranch! ...)) :
    DefUnion(closest-info(),
             unwrap-token(name),
             type,
             to-tuple(branches))

  ;Syntax for a single union branch.
  defproduction ubranch!: UnionBranch
  defrule ubranch! = (?type:#type! #:! ?constructor:#constructor!) :
    UnionBranch(closest-info(), type, constructor)

  ;Syntax for 'defcombinator'
  defrule texp! = (defcombinator ?name:#id! (?args:#combinator-arg! ...)
                                 (?binder:#id! #:! ?type:#type$) #:! (
                     #writer! #:! (?writer-exps ...)
                     #reader! #:! (?reader-exps ...))) :
    DefCombinator(closest-info(),
                  unwrap-token(name),
                  to-tuple(args),
                  unwrap-token(binder),
                  type
                  writer-exps,
                  reader-exps)

  defproduction combinator-arg!: CombinatorArg
  defrule combinator-arg! = (?name:#id! #:! ?type-name:#id!) :
    CombinatorArg(closest-info(), unwrap-token(name), unwrap-token(type-name))
  

  ;Syntax for other stanza expressions.
  defrule texp! = (?e:#exp!) :
    StanzaExp(closest-info(), e)

  ;----------------------------------------------------------
  ;---------------------- Constructors ----------------------
  ;----------------------------------------------------------
  defproduction constructor!: Constructor

  ;Syntax for Enum constructors
  defrule constructor! = (enum) :
    EnumConstructor()

  ;Syntax for Struct constructors
  defrule constructor! = ((?args:#struct-field! ...)) :
    StructConstructor(to-tuple(args))

  defproduction struct-field!: StructField
  defrule struct-field! = (?name:#id! #:! ?spec:#spec!) :
    StructField(unwrap-token(name), spec)

  ;Syntax for Existing specs
  defrule constructor! = (?s:#spec!)

  ;----------------------------------------------------------
  ;-------------------- Specifications ----------------------
  ;----------------------------------------------------------
  defproduction spec: IOSpec

  ;Syntax for casted specification.
  defrule spec = (?spec:#spec as ?type:#type!) :
    CastedSpec(spec, type)

  ;Syntax for combinator specification.
  defrule spec = (?name:#id(?args:#spec! ...)) :
    CombinatorSpec(unwrap-token(name), to-tuple(args))

  ;Syntax for named definition.
  defrule spec = (?name:#id) :
    NamedSpec(unwrap-token(name))

  ;Force specification.
  defproduction spec!: IOSpec
  defrule spec! = (?s:#spec) : s
  fail-if spec! = () : FSE(closest-info(), "Invalid syntax for specification.")

  ;----------------------------------------------------------
  ;---------------------- Keywords --------------------------
  ;----------------------------------------------------------
  defproduction writer!
  defrule writer! = (writer)
  fail-if writer! = () : FSE(closest-info(), "Expected keyword 'writer' here.")

  defproduction reader!
  defrule reader! = (reader)
  fail-if reader! = () : FSE(closest-info(), "Expected keyword 'reader' here.")

  ;----------------------------------------------------------
  ;-------------------- Primitives --------------------------
  ;----------------------------------------------------------
  defproduction string: String|Token
  defrule string = (?s) when unwrap-token(s) is String

  defproduction int: Int
  defrule int = (?s) when unwrap-token(s) is Int

  ;----------------------------------------------------------
  ;----------------------- Errors ---------------------------
  ;----------------------------------------------------------
  defn FSE (info:FileInfo|False, msg) :
    FastIOSyntaxError(info, msg)
