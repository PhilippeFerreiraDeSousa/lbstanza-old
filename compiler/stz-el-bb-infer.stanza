defpackage stz/el-bb-infer :
  import core
  import collections
  import stz/el-ir
  import stz/utils

;============================================================
;================== Input Specification =====================
;============================================================

;Represents a chunk of code.
;- freevars: Contains the free variables that
;  are referred to by nested code. 
public defstruct Code :
  n: Int
  locals: Tuple<Local>
  nested: Tuple<Code>
  blocks: Tuple<Block>
  freevars: Tuple<Int>

;Records information about the local variables
;in a code block.
public defstruct Local :
  n: Int
  mutable?: True|False
  type: EType

;Represents every basic block.
public defstruct Block :
  n: Int
  instructions: Tuple<Ins>
  predecessors: Tuple<Int>

;------------------------------------------------------------
;--------------------- Instructions -------------------------
;------------------------------------------------------------

public deftype Ins

;Represents the definition, or assignment, of a variable.
public defstruct Def <: Ins :
  n: Int
  type: EType

;Represents when a variable is defined as, or assigned from,
;another variable. It inherits the type of that variable.
public defstruct Inherit <: Ins :
  n: Int
  v: Int

;Represents a cast. The given variable is dynamically checked
;to be of the given type, and the program halts if it is not.
public defstruct Cast <: Ins :
  n: Int
  type: EType

;Represents a match. Depending on which branch we enter,
;a different set of conditions apply.
;This instruction must be the last instruction in the
;block if it is used.
public defstruct Match <: Ins :
  branches: Tuple<Branch>

;Represents the target of a match. If we jump to this
;branch, then we assume that the given casts have passed.
public defstruct Branch :
  n: Int
  casts: Tuple<Cast>

;Represents the use of a variable. We will add annotations
;for variables wherever we see these instructions.
public defstruct Use <: Ins :
  n: Int

;Indicates that the nested code block is created at
;this point.
public defstruct InitCode <: Ins :
  n: Int

;Represents the original instruction here.
public defstruct Wrapped<T> <: Ins :
  value:T

;============================================================
;================== Output Specification ====================
;============================================================

public defstruct AnnotatedCodes :
  codes: Tuple<AnnotatedCode>

public defstruct AnnotatedCode :
  n: Int
  instructions: Tuple<Ins>

;============================================================
;================ Abstract Representations ==================
;============================================================

;Represents the type of variable 'n' at the entry
;to block 'block' in code 'code'.
defstruct EnterType <: EType :
  n: Int
  block: Int

;Represents the type of the mutable variable 'n'.
defstruct MutableVarType <: EType :
  n: Int

;------------------------------------------------------------
;----------------- Hashing and Equality ---------------------
;------------------------------------------------------------

defmethod hash (t:EnterType) :
  hash([13, n(t), block(t)])

defmethod equal? (a:EnterType, b:EnterType) :
  n(a) == n(b) and block(a) == block(b)

defmethod hash (v:MutableVarType) :
  n(v)
  
defmethod equal? (a:MutableVarType, b:MutableVarType) :
  n(a) == n(b)

;------------------------------------------------------------
;----------------------- Mapping ----------------------------
;------------------------------------------------------------

defmethod map (f:ELItem -> ELItem, item:EnterType) : item
defmethod map (f:ELItem -> ELItem, item:MutableVarType) : item

;============================================================
;================= Inference Algorithm ======================
;============================================================

;defn annotate (code:Code, entry-state:Tuple<KeyValue<Int,EType>>) :
;  val buffer = Vector<Ins>()
;  for block in blocks(code) do :

;============================================================
;=================== Block Annotation =======================
;============================================================

;------------------------------------------------------------
;----------------------- Output -----------------------------
;------------------------------------------------------------
;This represents the code structure with its blocks annotated.
;It mirrors the structure of the input Code.
;- escaped-mutable-vars: is the list of all locally defined reftype
;  mutable variables that are assigned to within a nested block.
defstruct AnnotatedBlocks :
  n: Int
  locals: Tuple<Local>
  blocks: Tuple<AnnotatedBlock>
  nested: Tuple<AnnotatedBlocks>
  escaped-mutable-vars: Tuple<Int>

;This represents the result of running inference on a block.
;- n: the identifier of the block.
;- ins: the instructions with added Annotate instructions.
;- enter-vars: the reftype vars whose types enter the block.
;  Escaped mutable variables are not included here.
;- exit-types: the types of the reftype variables at block exit.
;  Note that this only contains the types of any variables
;  that were affected within the block. Variables that are simply
;  live in the block, and enter and exit unaffected do not
;  appear here.
;  Escaped mutable variables are not included here.
;- assigned-types: the assigned types of any reftype mutable
;  variables. Note that each entry represents a separate assignment,
;  so the same variable may appear multiple times.
;- nested: the code chunks that were created within the block.
;- predecessors: the predecessor blocks.
defstruct AnnotatedBlock :
  n:Int
  ins:Tuple<Ins>
  enter-vars:Tuple<Int>
  exit-types:Tuple<KeyValue<Int,EType|ExitType>>
  assigned-types:Tuple<KeyValue<Int,EType>>
  nested:Tuple<NestedState>
  predecessors:Tuple<Int>

;This indicates that a nested code chunk was created
;within this block.
;- free-types: the inferred types of the free variables
;  at the moment of creation. Mutable variables do not appear
;  here.
defstruct NestedState :
  n:Int
  free-types:Tuple<KeyValue<Int,EType>>

;This indicates that a type that only applies if
;we jump to a specific block. It is used in the exit-types
;field. Each entry, block => type, indicates that the final
;type is 'type' if we jump to block 'block'.
defstruct ExitType :
  entries:Tuple<KeyValue<Int,EType>>

;------------------------------------------------------------
;--------------- Annotate a Single Block --------------------
;------------------------------------------------------------
    
;defn annotate-block (block:Block) -> AnnotatedBlock :
;  ;State of each variable.
;  val state = IntTable-init<EType>(EnterType{_, n(block)})
;
;  for ins in instructions(block) do :
;    match(ins) :
;      (ins:Def) :
        
;============================================================
;================= Equation Construction ====================
;============================================================

;Returns the constructed type equations for the given annotated blocks.
;Each output entry, v => type, indicates that the type v is inferred to be type.
;v is either EnterType or MutableVarType. 
defn construct-equations (annotated-blocks:AnnotatedBlocks,
                          trust-declared-types?:True|False) -> HashTable<EType,EType> :
  ;Whenever an EnterType is used in one of the equations, we
  ;add it to this queue to ensure that we construct an
  ;equation for it. Each entry is [code, enter-type]. 
  val used-enter-types = Queue<[Int,EnterType]>()
  defn use-enter-type (code:Int, v:Int, block:Int) -> EnterType :
    val t = EnterType(v,block)
    add(used-enter-types, [code,t])
    t

  ;Used to hold information about exit types in annotated-blocks
  ;for quick lookup. Each entry [v,block] => type indicates that
  ;the variable v has type 'type' when it exists block 'block'.
  val exit-type-table = HashTable<[Int,Int],EType|ExitType>()

  ;Used to hold information about block predecessors for quick lookup.
  ;Each entry [code,block] => preds indicates that the block 'block'
  ;in code 'code' has predecessor blocks 'preds'.
  val pred-table = HashTable<[Int,Int],Tuple<Int>>()

  ;Used to hold information about the first block in each code.
  ;Each entry, code => block0, indicates that 'block0' is the first
  ;block in the given code 'code'.
  val block0-table = IntTable<Int>()

  ;Used to hold the declared types of all variables.
  ;Each entry, v => t, indicates that the variable v was declared
  ;with type t.
  val declared-type-table = IntTable<EType>()

  ;Compute the exiting type of variable v when going from block 'block'
  ;to successor 'succ'.
  defn compute-exit-type (code:Int, v:Int, block:Int, succ:Int) -> EType :
    match(get?(exit-type-table, [v,block])) :
      (f:False) : use-enter-type(code, v, block)
      (t:EType) : t
      (t:ExitType) : lookup(entries(t), succ)

  ;Compute the entering type of variable v when entering block 'block'.
  ;Returns false if it cannot be computed from its predecessor blocks.
  defn compute-enter-type (code:Int, v:Int, block:Int) -> EType|False :
    val preds = pred-table[[code,block]]
    if not empty?(preds) :
      ;Get the exiting types from the predecessor blocks.
      val exit-types = for pred in preds seq :
        compute-exit-type(code, v, pred, block)
      reduce(EOr, exit-types)

  ;If trust-declared-types? is true, then we return the
  ;type t intersected with the type that v was originally declared
  ;with, otherwise just return the type t directly.
  defn intersect-with-declared-type? (v:Int, t:EType) -> EType :
    if trust-declared-types? : EAnd(t, declared-type-table[v])
    else : t

  ;Recurse through all codes.
  ;Calls return on all code entries.
  defn recurse-through-codes (return:AnnotatedBlocks -> ?) :
    let loop (b:AnnotatedBlocks = annotated-blocks) :
      return(b)
      do(loop, nested(b))
      
  ;Recurse through all annotated blocks.
  ;Calls return on all (code, block) entries.
  defn recurse-through-blocks (return:(Int,AnnotatedBlock) -> ?) :
    let loop (b:AnnotatedBlocks = annotated-blocks) :
      do(return{n(b), _}, blocks(b))
      do(loop, nested(b))  

  ;Populate tables.
  ;Fill the exit-type-table, pred-table, block0-table, declared-type-table.
  within b = recurse-through-codes() :
    val block0 = n(blocks(b)[0])
    block0-table[n(b)] = block0
    for l in locals(b) do :
      declared-type-table[n(l)] = type(l)
  within (code,block) = recurse-through-blocks() :
    for entry in exit-types(block) do :
      val v = key(entry)
      exit-type-table[[v, n(block)]] = value(entry)
    pred-table[[code,n(block)]] = predecessors(block)

  ;Create vector for storing all generated equations.
  val eqns = HashTable<EnterType|MutableVarType,EType>()

  ;Generate all equations that relate enter types to
  ;exit types of predecessors.
  ;Initialize enter types queue.
  within (code, block) = recurse-through-blocks() :
    for v in enter-vars(block) do :
      use-enter-type(code, v, n(block))
  ;Iteratively construct equations for any used enter types.
  while not empty?(used-enter-types) :
    val [code, t] = pop(used-enter-types)
    if not key?(eqns, t) :
      val type = compute-enter-type(code, n(t), block(t))
      match(type:EType) :
        eqns[t] = type
 
  ;Generate all enter-type equations from nested state.
  within (code, block) = recurse-through-blocks() :
    for nested in nested(block) do :
      ;Retrieve the first block in the code 'n'.
      val block0 = block0-table[code]
      ;Generate the enter-type equations for the nested code.
      for entry in free-types(nested) do :
        val v = key(entry)
        val t = EnterType(v, block0)
        eqns[t] = value(entry)

  ;Generate all mutable var equations.
  val assigned-vars = group-by{key, value, _} $
    generate<KeyValue<Int, EType>> :
      within (code, block) = recurse-through-blocks() :
        do(yield, assigned-types(block))
  within b = recurse-through-codes() :
    for v in escaped-mutable-vars(b) do :
      val t = match(get?(assigned-vars, v)) :
        (f:False) : EBot()
        (ts:List<EType>) : reduce(EOr, ts)
      eqns[MutableVarType(v)] = intersect-with-declared-type?(v,t)

  ;Return all generated eqns
  eqns