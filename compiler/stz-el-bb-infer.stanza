defpackage stz/el-bb-infer :
  import core
  import collections
  import stz/el-ir
  import stz/utils

;============================================================
;================== Input Specification =====================
;============================================================

;Represents a chunk of code.
;- freevars: Contains the free variables that
;  are referred to by nested code.
public defstruct Code :
  n: Int
  family: Int
  locals: Tuple<Local>
  nested: Tuple<Code>
  blocks: Tuple<Block>
  freevars: Tuple<Int>

;Records information about the local variables
;in a code block.
public defstruct Local :
  n: Int
  mutable?: True|False
  type: EType

;Represents every basic block.
public defstruct Block :
  n: Int
  instructions: Tuple<Ins>
  predecessors: Tuple<Int>

;------------------------------------------------------------
;--------------------- Instructions -------------------------
;------------------------------------------------------------

public deftype Ins

;Represents the definition, or assignment, of a variable.
public defstruct Def <: Ins :
  n: Int
  type: EType

;Represents when a variable is defined as, or assigned from,
;another variable. It inherits the type of that variable.
public defstruct Inherit <: Ins :
  n: Int
  v: Int

;Represents a cast. The given variable is dynamically checked
;to be of the given type, and the program halts if it is not.
public defstruct Cast <: Ins :
  n: Int
  type: EType

;Represents a match. Depending on which branch we enter,
;a different set of conditions apply.
;This instruction must be the last instruction in the
;block if it is used.
public defstruct Match <: Ins :
  branches: Tuple<Branch>

;Represents the target of a match. If we jump to this
;branch, then we assume that the given casts have passed.
public defstruct Branch :
  n: Int
  casts: Tuple<Cast>

;Represents the use of a variable. We will add annotations
;for variables wherever we see these instructions.
public defstruct Use <: Ins :
  n: Int

;Indicates that the nested code block is created at
;this point.
public defstruct InitCode <: Ins :
  family: Int

;Indicates the type of the variable n just after
;this instruction.
public defstruct Annotate <: Ins :
  n: Int
  type: EType

;Represents the original instruction here.
public defstruct Wrapped<T> <: Ins :
  value:T

;============================================================
;====================== Printer =============================
;============================================================

defmethod print (o:OutputStream, c:Code) :
  val items = cat-all $ [
    ["freevars: (%,)" % [freevars(c)]]
    locals(c),
    nested(c),
    blocks(c)]
  print(o, "code %_ (family = %_) %_" % [n(c), family(c), colon-list(items)])

defmethod print (o:OutputStream, l:Local) :
  val mutable-str = " (mutable)" when mutable?(l) else ""
  print(o, "local %_: %_%_" % [n(l), type(l), mutable-str])

defmethod print (o:OutputStream, l:Block) :
  val items = cat-all $ [
    ["predecessors: (%,)" % [predecessors(l)]]
    instructions(l)]
  print(o, "block %_ %_" % [n(l), colon-list(items)])

defmethod print (o:OutputStream, ins:Ins) :
  print{o, _} $ match(ins) :
    (ins:Def) : "def %_: %_" % [n(ins), type(ins)]
    (ins:Inherit) : "inherit %_ from %_" % [n(ins), v(ins)]
    (ins:Cast) : "cast %_ to %_" % [n(ins), type(ins)]
    (ins:Match) : "match%_" % [colon-list(branches(ins))]
    (ins:Use) : "use %_" % [n(ins)]
    (ins:InitCode) : "init family %_" % [family(ins)]
    (ins:Annotate) : "annotate %_: %_" % [n(ins), type(ins)]
    (ins:Wrapped) : "wrapped: %~" % [to-string(value(ins))]

defmethod print (o:OutputStream, b:Branch) :
  defn fmt (c:Cast) : "%_:%_" % [n(c), type(c)]
  print(o, "(%,) -> block %_" % [seq(fmt, casts(b)), n(b)])

defn colon-list (input-xs:Seqable) :
  val xs = to-seq(input-xs)
  if empty?(xs) : ": ()"
  else : ":\n%_" % [Indented("%n" % [xs])]

;============================================================
;=============== Input Consistency Check ====================
;============================================================

defn ensure-wellformed! (input:Code) :
  defn ensure-ref-type! (l:Local) :
    if type(l) is-not EOf|ETVar|EAnd|EOr|ETop|EBot :
      fatal("Local %_ is not a ref type." % [n(l)])

  ;Recurse into nested codes.
  defn do-nested-codes (f:Code -> ?, c:Code) :
    f(c)
    do(do-nested-codes{f, _}, nested(c))

  ;Recurse into nested blocks.
  defn do-nested-blocks (f:Block -> ?, c:Code) :
    do(f, blocks(c))
    do(do-nested-blocks{f, _}, nested(c))

  ;Ensure all locals are proper.
  for code in input do-nested-codes :
    do(ensure-ref-type!, locals(code))

  ;Ensure that all instructions are used properly.
  for block in input do-nested-blocks :
    val len = length(instructions(block))
    for (ins in instructions(block), i in 0 to false) do :
      match(ins) :
        (ins:Match) :
          if i != len - 1 :
            fatal("Match in block %_ is not last instruction." % [n(block)])
          val branch0 = branches(ins)[0]
          val cast-ns0 = map(n, casts(branch0))
          for b in branches(ins) do :
            val cast-ns = map(n, casts(b))
            if cast-ns != cast-ns0 :
              fatal("Casts in match are not consistent against each other.")
        (ins) :
          false


;============================================================
;================== Output Specification ====================
;============================================================

public defstruct AnnotatedCodes :
  codes: Tuple<AnnotatedCode>

public defstruct AnnotatedCode :
  n: Int
  instructions: Tuple<Ins>

;============================================================
;================ Abstract Representations ==================
;============================================================

;Represents the type of variable 'n' at the entry
;to block 'block' in code 'code'.
defstruct EnterType <: EType :
  n: Int
  block: Int

;Represents the type of the mutable variable 'n'.
defstruct MutableVarType <: EType :
  n: Int

;------------------------------------------------------------
;----------------- Hashing and Equality ---------------------
;------------------------------------------------------------

defmethod hash (t:EnterType) :
  hash([13, n(t), block(t)])

defmethod equal? (a:EnterType, b:EnterType) :
  n(a) == n(b) and block(a) == block(b)

defmethod hash (v:MutableVarType) :
  n(v)

defmethod equal? (a:MutableVarType, b:MutableVarType) :
  n(a) == n(b)

;------------------------------------------------------------
;----------------------- Mapping ----------------------------
;------------------------------------------------------------

defmethod map (f:ELItem -> ELItem, item:EnterType) : item
defmethod map (f:ELItem -> ELItem, item:MutableVarType) : item

;============================================================
;================= Inference Algorithm ======================
;============================================================

;defn annotate (code:Code, entry-state:Tuple<KeyValue<Int,EType>>) :
;  val buffer = Vector<Ins>()
;  for block in blocks(code) do :

;============================================================
;=================== Block Annotation =======================
;============================================================

;------------------------------------------------------------
;----------------------- Output -----------------------------
;------------------------------------------------------------
;This represents the code structure with its blocks annotated.
;It mirrors the structure of the input Code.
;- escaped-mutable-vars: is the list of all locally defined reftype
;  mutable variables that are assigned to within a nested block.
defstruct AnnotatedBlocks :
  n: Int
  locals: Tuple<Local>
  blocks: Tuple<AnnotatedBlock>
  nested: Tuple<AnnotatedBlocks>
  escaped-mutable-vars: Tuple<Int>

;This represents the result of running inference on a block.
;- n: the identifier of the block.
;- ins: the instructions with added Annotate instructions.
;- enter-vars: the reftype vars whose types enter the block.
;  Escaped mutable variables are not included here.
;- exit-types: the types of the reftype variables at block exit.
;  Note that this only contains the types of any variables
;  that were affected within the block. Variables that are simply
;  live in the block, and enter and exit unaffected do not
;  appear here.
;  Escaped mutable variables are not included here.
;- assigned-types: the assigned types of any reftype mutable
;  variables. Note that each entry represents a separate assignment,
;  so the same variable may appear multiple times.
;- nested: the code chunks that were created within the block.
;- predecessors: the predecessor blocks.
defstruct AnnotatedBlock :
  n:Int
  ins:Tuple<Ins>
  enter-vars:Tuple<Int>
  exit-types:Tuple<KeyValue<Int,EType|ExitType>>
  assigned-types:Tuple<KeyValue<Int,EType>>
  nested:Tuple<NestedState>
  predecessors:Tuple<Int>

;This indicates that a nested code chunk was created
;within this block.
;- free-types: the inferred types of the free variables
;  at the moment of creation. Mutable variables do not appear
;  here.
defstruct NestedState :
  n:Int
  free-types:Tuple<KeyValue<Int,EType>>

;This indicates that a type that only applies if
;we jump to a specific block. It is used in the exit-types
;field. Each entry, block => type, indicates that the final
;type is 'type' if we jump to block 'block'.
defstruct ExitType :
  entries:Tuple<KeyValue<Int,EType>>

;------------------------------------------------------------
;--------------- Annotate a Single Block --------------------
;------------------------------------------------------------

;Annotate a single block.
;- block: the block to annotate.
;- family-table: the table holding the identifiers of the code
;  blocks in each family.
;- declared-type-table: the table holding the declared types
;  of all the locals.
;- freevar-table: the table holding the free variables
;  of each code object. Each entry, code => vs, indicates that
;  the code block 'code' has free variables 'vs'.
;- escaped-mutables: the set of escaped mutable variables.
;- trust-declared-types?: true if the inference algorithm
;  should trust the declared types.
defn annotate-block (block:Block,
                     family-table:IntTable<Tuple<Int>>,
                     declared-type-table:IntTable<EType>,
                     freevar-table:IntTable<Tuple<Int>>,
                     escaped-mutables:IntSet,
                     trust-declared-types?:True|False) -> AnnotatedBlock :
  ;State of each variable.
  val state = IntTable-init<EType>(EnterType{_, n(block)})

  ;Accumulate new instructions and assignments.
  val instructions* = Vector<Ins>()
  val nested* = Vector<NestedState>()
  val assigned* = Vector<KeyValue<Int,EType>>()
  val exit-types* = IntTable<ExitType>()
  defn emit (i:Ins) : add(instructions*, i)
  defn emit-nested (s:NestedState) : add(nested*, s)
  defn emit-assigned (v:Int, t:EType) : add(assigned*, v => t)
  defn emit-exit-type (v:Int, t:ExitType) : exit-types*[v] = t

  ;If trust-declared-types? is true, returns the intersection
  ;of t and the declared type of v. Otherwise returns t unchanged.
  defn intersect-with-declared-type? (v:Int, t:EType) -> EType :
    fatal("Not yet implemented")

  ;Scan through each instruction, and add
  ;to the various accumulators.
  for ins in instructions(block) do :
    match(ins) :
      (ins:Def) :
        if escaped-mutables[n(ins)] :
          ;Add type(ins) as another type that has been assigned
          ;to the variable 'n'.
          emit-assigned(n(ins), type(ins))
        else :
          ;Assign to the variable's current state.
          state[n(ins)] = intersect-with-declared-type?(n(ins), type(ins))
      (ins:Inherit) :
        val vtype = state[v(ins)]
        if escaped-mutables[n(ins)] :
          ;Add vtype as another type that has been assigned
          ;to the variable 'n'.
          emit-assigned(n(ins), vtype)
        else :
          ;Inherit the state from the given variable.
          state[n(ins)] = intersect-with-declared-type?(n(ins), vtype)
      (ins:Cast) :
        if not escaped-mutables[n(ins)] :
          ;Intersect the current type of the given variable.
          val type* = EAnd(state[n(ins)], type(ins))
          state[n(ins)] = type*
      (ins:Match) :
        if not empty?(branches(ins)) :
          ;Each entry in var-indices, [v, i], indicates that
          ;variable v is the i'th cast in each branch, and v's
          ;exit type needs to be calculated.
          val branch0 = branches(ins)[0]
          val var-indices = to-tuple $
            for (c in casts(branch0), i in 0 to false) seq? :
              if escaped-mutables[n(c)] : None()
              else : One([n(c), i])
          ;Exit the exit types for each variable.
          for [v, i] in var-indices do :
            val exit-type = ExitType $
              for b in branches(ins) map :
                val cast = casts(b)[i]
                n(b) => EAnd(state[v], type(cast))
            emit-exit-type(v, exit-type)
      (ins:Use) :
        ;Add an annotation instruction here.
        val type = state[n(ins)]
        emit(Annotate(n(ins), type))
      (ins:InitCode) :
        ;For each code in the family.
        for n in family-table[family(ins)] do :
          ;Retrieve the current state of the free variables.
          val freevars = freevar-table[n]
          val free-types = for v in freevars map : v => state[v]
          ;Construct the nested state.
          emit-nested(NestedState(n, free-types))
      (ins:Wrapped) :
        ;Emit wrapped instructions as they are.
        emit(ins)

  ;Compute the final exit types
  defn compute-exit-types () -> Tuple<KeyValue<Int,EType|ExitType>> :
    to-tuple $ for entry in state seq :
      val v = key(entry)
      match(get?(exit-types*, v)) :
        (t:ExitType) : v => t
        (f:False) : v => value(entry)

  ;Return annotated block
  AnnotatedBlock(n(block),
                 to-tuple(instructions*),
                 to-tuple(keys(state)),
                 compute-exit-types(),
                 to-tuple(assigned*),
                 to-tuple(nested*),
                 predecessors(block))

;------------------------------------------------------------
;----------------- Detect Escaped Mutables ------------------
;------------------------------------------------------------

;Detect all the mutable variables that are assigned to
;within a nested context. Returns a table where each entry,
;n => vs, indicates that the locals 'vs' in the code 'n' are
;assigned to within a nested context.
defn detect-escaped-mutables (code:Code) -> IntTable<Tuple<Int>> :
  ;Scan through the given code.
  ;- non-local-assign: called whenever an
  ;  instruction assigns via Def or Inherit
  ;  to a variable that is not defined locally.
  ;- escaped-mutable-vars: called with (code, vs)
  ;  where code is the identifier of the code, and vs
  ;  are all the locally defined mutable variables that
  ;  are assigned by a nested code.
  defn scan-for-non-local-assign (code:Code,
                                  non-local-assign:Int -> ?,
                                  escaped-mutable-vars:(Int, Tuple<Int>) -> ?) :
    ;Collect set of locals
    val local-table = to-inttable<Local> $
      for l in locals(code) seq : n(l) => l

    ;Scan our own instructions.
    ;Call non-local-assign on any variables that are assigned
    ;to that are not defined locally.
    for ins in seq-cat(instructions, blocks(code)) do :
      match(ins:Def|Inherit) :
        if not key?(local-table, n(ins)) :
          non-local-assign(n(ins))

    ;Scan our nested codes.
    ;For any nested non-local assign, either call non-local-assign if it is not defined
    ;locally, or add to our set of escaped-mutables if it is.
    val escaped-mutable-set = IntSet()
    for code in nested(code) do :
      scan-for-non-local-assign(code,
                                nested-non-local-assign,
                                escaped-mutable-vars) where :
        ;Called when a nested code assigns a non-local variable.
        defn nested-non-local-assign (v:Int) :
          match(get?(local-table, v)) :
            (l:Local) :
              ;Assigned to local in this code.
              if not mutable?(l) :
                fatal("Local %_ is not mutable, but was assigned to by a nested context." % [n(l)])
              add(escaped-mutable-set, v)
            (f:False) :
              ;Not defined in this code either.
              non-local-assign(v)
    escaped-mutable-vars(n(code), to-tuple(escaped-mutable-set))

  ;Collect all the escaped mutable variables.
  val escaped-mutables = IntTable<Tuple<Int>>()
  scan-for-non-local-assign(code, illegal-non-local-assign, add-to-escaped-mutables) where :
    defn illegal-non-local-assign (v:Int) :
      fatal("Illegal assignment to variable %_." % [v])
    defn add-to-escaped-mutables (n:Int, vs:Tuple<Int>) :
      escaped-mutables[n] = vs

  ;Return all escaped mutable variables.
  escaped-mutables



;============================================================
;================= Equation Construction ====================
;============================================================

;Returns the constructed type equations for the given annotated blocks.
;Each output entry, v => type, indicates that the type v is inferred to be type.
;v is either EnterType or MutableVarType.
defn construct-equations (annotated-blocks:AnnotatedBlocks,
                          trust-declared-types?:True|False) -> Tuple<KeyValue<EType,EType>> :
  ;Whenever an EnterType is used in one of the equations, we
  ;add it to this queue to ensure that we construct an
  ;equation for it. Each entry is [code, enter-type].
  val used-enter-types = Queue<[Int,EnterType]>()
  defn use-enter-type (code:Int, v:Int, block:Int) -> EnterType :
    val t = EnterType(v,block)
    add(used-enter-types, [code,t])
    t

  ;Used to hold information about exit types in annotated-blocks
  ;for quick lookup. Each entry [v,block] => type indicates that
  ;the variable v has type 'type' when it exists block 'block'.
  val exit-type-table = HashTable<[Int,Int],EType|ExitType>()

  ;Used to hold information about block predecessors for quick lookup.
  ;Each entry [code,block] => preds indicates that the block 'block'
  ;in code 'code' has predecessor blocks 'preds'.
  val pred-table = HashTable<[Int,Int],Tuple<Int>>()

  ;Used to hold information about the first block in each code.
  ;Each entry, code => block0, indicates that 'block0' is the first
  ;block in the given code 'code'.
  val block0-table = IntTable<Int>()

  ;Used to hold the declared types of all variables.
  ;Each entry, v => t, indicates that the variable v was declared
  ;with type t.
  val declared-type-table = IntTable<EType>()

  ;Compute the exiting type of variable v when going from block 'block'
  ;to successor 'succ'.
  defn compute-exit-type (code:Int, v:Int, block:Int, succ:Int) -> EType :
    match(get?(exit-type-table, [v,block])) :
      (f:False) : use-enter-type(code, v, block)
      (t:EType) : t
      (t:ExitType) : lookup(entries(t), succ)

  ;Compute the entering type of variable v when entering block 'block'.
  ;Returns false if it cannot be computed from its predecessor blocks.
  defn compute-enter-type (code:Int, v:Int, block:Int) -> EType|False :
    val preds = pred-table[[code,block]]
    if not empty?(preds) :
      ;Get the exiting types from the predecessor blocks.
      val exit-types = for pred in preds seq :
        compute-exit-type(code, v, pred, block)
      reduce(EOr, exit-types)

  ;If trust-declared-types? is true, then we return the
  ;type t intersected with the type that v was originally declared
  ;with, otherwise just return the type t directly.
  defn intersect-with-declared-type? (v:Int, t:EType) -> EType :
    if trust-declared-types? : EAnd(t, declared-type-table[v])
    else : t

  ;Recurse through all codes.
  ;Calls return on all code entries.
  defn recurse-through-codes (return:AnnotatedBlocks -> ?) :
    let loop (b:AnnotatedBlocks = annotated-blocks) :
      return(b)
      do(loop, nested(b))

  ;Recurse through all annotated blocks.
  ;Calls return on all (code, block) entries.
  defn recurse-through-blocks (return:(Int,AnnotatedBlock) -> ?) :
    let loop (b:AnnotatedBlocks = annotated-blocks) :
      do(return{n(b), _}, blocks(b))
      do(loop, nested(b))

  ;Populate tables.
  ;Fill the exit-type-table, pred-table, block0-table, declared-type-table.
  within b = recurse-through-codes() :
    val block0 = n(blocks(b)[0])
    block0-table[n(b)] = block0
    for l in locals(b) do :
      declared-type-table[n(l)] = type(l)
  within (code,block) = recurse-through-blocks() :
    for entry in exit-types(block) do :
      val v = key(entry)
      exit-type-table[[v, n(block)]] = value(entry)
    pred-table[[code,n(block)]] = predecessors(block)

  ;Create vector for storing all generated equations.
  val eqns = HashTable<EnterType|MutableVarType,EType>()

  ;Generate all equations that relate enter types to
  ;exit types of predecessors.
  ;Initialize enter types queue.
  within (code, block) = recurse-through-blocks() :
    for v in enter-vars(block) do :
      use-enter-type(code, v, n(block))
  ;Iteratively construct equations for any used enter types.
  while not empty?(used-enter-types) :
    val [code, t] = pop(used-enter-types)
    if not key?(eqns, t) :
      val type = compute-enter-type(code, n(t), block(t))
      match(type:EType) :
        eqns[t] = type

  ;Generate all enter-type equations from nested state.
  within (code, block) = recurse-through-blocks() :
    for nested in nested(block) do :
      ;Retrieve the first block in the code 'n'.
      val block0 = block0-table[code]
      ;Generate the enter-type equations for the nested code.
      for entry in free-types(nested) do :
        val v = key(entry)
        val t = EnterType(v, block0)
        eqns[t] = value(entry)

  ;Generate all mutable var equations.
  val assigned-vars = group-by{key, value, _} $
    generate<KeyValue<Int, EType>> :
      within (code, block) = recurse-through-blocks() :
        do(yield, assigned-types(block))
  within b = recurse-through-codes() :
    for v in escaped-mutable-vars(b) do :
      val t = match(get?(assigned-vars, v)) :
        (f:False) : EBot()
        (ts:List<EType>) : reduce(EOr, ts)
      eqns[MutableVarType(v)] = intersect-with-declared-type?(v,t)

  ;Return all generated eqns
  to-tuple(eqns)

;============================================================
;==================== Equation Solver =======================
;============================================================

;Solve the given type equations and return a table
;of solutions.
defn solve-equations (eqns:Tuple<KeyValue<EType,EType>>) -> HashTable<EType,EType> :
  ;Holds the final inferred solutions.
  val soln-table = HashTable<EType,EType>()

  ;Recurse into the type t, and replace any
  ;abstract types with their corresponding entry
  ;in the solution table. The result is guaranteed not
  ;to contain any abstract types that are keys in soln-table.
  ;- soln-table-contains-further-references?: is a flag that
  ;  describes the structure of soln-table. If false it means that
  ;  any retrieved entry in soln-table is guaranteed not to contain
  ;  further keys in soln-table, and therefore we do not need to
  ;  recurse on a retrieved result.
  defn sub-solns (t:EType,
                  soln-table-contains-further-references?:True|False) -> EType :
    ;Use f to map over all nested abstract types in t.
    defn map-over-abstract-types (f:EnterType|MutableVarType -> EType, t:EType) -> EType :
      let loop (t:EType = t) :
        match(t:EnterType|MutableVarType) : f(t)
        else : map(loop, t)
    ;Substitute abstract types using entries from soln-table.
    ;Record whether any substitutions have been made.
    var subbed? = false
    val t* = for subt in t map-over-abstract-types :
      match(get?(soln-table, subt)) :
        (subt*:EType) :
          subbed? = true
          subt*
        (f:False) :
          subt
    ;Check whether any substitutions were actually made.
    if subbed? and soln-table-contains-further-references? :
      ;If substitutions were made, and there may exist more references,
      ;then iterate again.
      sub-solns(t*, soln-table-contains-further-references?)
    else :
      ;If no substitutions were made, then just normalize and
      ;return.
      normalize(t*)

  ;Ensure that we solved it correctly, and that
  ;equations were set up properly.
  defn ensure-soln! (t:EType) :
    var contains-abstract-types? = false
    let loop (t:EType = t) :
      match(t:EnterType|MutableVarType) :
        contains-abstract-types? = true
      else : do*(loop, t)
    if contains-abstract-types? :
      fatal("Invalid solution: %_." % [t])

  ;Forward solve
  for entry in eqns do :
    val v = key(entry)
    ;If a variable is dependent upon itself, then use EBot as the fixed point
    ;solution.
    soln-table[v] = EBot()
    val type* = sub-solns(value(entry), true)
    soln-table[v] = type*
  ;Backward solve
  for v in seq(key,in-reverse(eqns)) do :
    val type* = sub-solns(soln-table[v], false)
    ensure-soln!(type*)
    soln-table[v] = type*

  ;Return solution
  soln-table