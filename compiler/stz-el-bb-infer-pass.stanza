defpackage stz/el-bb-infer-pass :
  import core
  import collections
  import stz/el-ir
  import stz/dl-ir
  import stz/el-var-table
  import stz/el-bb-infer
  import stz/el
  import stz/basic-ops
  import stz/el-utils

;============================================================
;===================== Main Driver ==========================
;============================================================

public defn construct-code (epackage:EPackage, gvt:VarTable) -> Code :
  defn process-body (b:EBody, vt:VarTable) :
    fatal("Process Body")
  defn process-fn (f:EFn, vt:VarTable) :
    construct-code(-1, args(f), a1(f), body(f), free(f))
    fatal("Process fn")
  defn process (texp:ELBigItem, vt:VarTable) -> ELBigItem :
    match(texp) :
      (texp:EBody) : process-body(texp, vt)
      (texp:EFn) : process-fn(texp, vt)
      (texp) : map(process{_, vt}, texp)


  within (texp, vt) = map-with-var-table(gvt, epackage) :
    val texp* = analyze-freevars(texp, vt)
    process(texp*, vt) as ETExp

  fatal("Not yet implemented")

defn construct-code (n:Int, args:Tuple<Int>, a1:Tuple<EType>, body:EBody, free:Free) -> Code : 
  defn analyze-block (block:BBlock) -> Block :
    println("Analyzing block %_" % [lbl(block)])
    do(println, instructions(block))
    fatal("Not yet implemented")

  ;Get the basic blocks
  val bbtable = analyze-basic-blocks(ins(body))
  do(analyze-block, bbtable)

  fatal("Not yet implemented")

defn map-with-var-table (f:(ETExp, VarTable) -> ETExp, gvt:VarTable, epackage:EPackage) -> EPackage :
  val exps* = for e in exps(epackage) map :
    f(e, LocalVarTable(gvt, e))
  sub-exps(epackage, exps*)

;============================================================
;==================== Utilities =============================
;============================================================

;Return true if the given variable refers to a
;variable that is handled by the inference engine.
;Variables must be local, and have a reftype. 
defn inferred-var? (vt:VarTable, n:Int) -> True|False :
  val record = vt[n]
  if not global?(record) :
    match(entry(record)) :
      ;Local functions are always simple closures.
      (e:FnEntry) : true 
      (e:VarEntry) : reftype?(type(e) as EType)

;Return true if the given immediate refers to a
;inferred variable in the inference engine.
defn inferred-var? (vt:VarTable, y:EImm) -> True|False :
  match(y:EVar) :
    inferred-var?(vt, n(y))

;Return true if the given variable location refers
;to an inferred variable in the inference engine.
defn inferred-var? (vt:VarTable, x:ELoc) -> True|False :
  match(x:EVarLoc) :
    inferred-var?(vt, n(x))

;Return the trusted type of the given global variable.
;It is assumed that the global variable has a reftype.
defn trusted-global-type (vt:VarTable, n:Int) -> EType :
  fatal("Not a global") when not global?(vt,n)
  if variable?(vt,n) :
    val t = type(vt,n)
    fatal("Not a reftype") when not reftype?(t)
    if lostanza?(vt,n) : ETop() ;Do not trust declared types of LoStanza variables.
    else : t                    ;Trust declared types of HiStanza variables.
  else if lostanza?(vt,n) :
    ;Ensure that the function can be used as a closure.
    val t = type(vt,n) as EFnT
    fatal("Cannot be a closure.") when r(t) is-not False
    fatal("Cannot be a closure.") when not all?(reftype?,a(t))
    fatal("Cannot be a closure.") when not reftype?(b(t))    
    ;Global functions just have type Fn
    EOf(/n(iotable(vt), CORE-FN-ID))
  else :
    ;Global functions just have type Fn
    EOf(/n(iotable(vt), CORE-FN-ID))

;============================================================
;================ Single Block Analysis =====================
;============================================================

defn analyze-single-block (emit:Ins -> ?,
                           b:BBlock,
                           vt:VarTable,
                           object-method-table:IntTable<Tuple<Int>>,
                           trust-declared-types?:True|False) :
  ;Utility: For any uses of inferred variables generate
  ;them here.
  defn gen-uses (ins:EIns) :
    for y in uses(ins) do :
      emit(Use(n(y as EVar))) when inferred-var?(vt,y)

  ;Utility: Retrieve the core type with the given id.
  defn core-type (id:TypeId) -> EOf :
    EOf(n(iotable(vt), id))

  ;Cases:
  ;  Cast commands: ECheck
  ;  Match commands: EMatch|EDispatch|EIf|ETypeof
  ;  Simple result commands: ETuple|EVoidTuple|EArray|EObject|EBox|
  ;                          ENewObject|ELetRec|EClosureGet|EObjectGet|
  ;                          EBoxGet|EInterpret|ELoad|ETupleGet|EPrim|ECall
  ;  Inherit commands: EDef|EStore
  ;  Initcode commands: EInitClosures|ENew
  ;  Trivial commands:

  ;Generate the commands for a cast command.
  ;Structure:
  ;  Use ...       - All referenced variables
  ;  Wrapped<Ins>  - The original wrapped instruction
  ;  Cast          - The cast command
  defn gen-cast-commands (ins:ECheck) :
    gen-uses(ins)
    if inferred-var?(vt,y(ins)) :
      val v = n(y(ins) as EVar)
      emit(Cast(v, type(ins)))
    emit(Wrapped<EIns>(ins))

  ;Generate the commands for a match command.
  ;Structure:
  ;  Use ...       - All referenced variables
  ;  Wrapped<Ins>  - The original wrapped instruction
  ;  Match         - The match command 
  defn gen-match-commands (ins:EMatch|EDispatch|EIf|ETypeof) :
    gen-uses(ins)
    emit(Wrapped<EIns>(ins))
    val branches = match(ins) :
      (ins:EMatch|EDispatch) :
        ;Each entry, [v, i], in var-indices indicates that
        ;variable v is an inferred variable and is argument i
        ;in the match.
        val var-indices = to-tuple $
          for (y in ys(ins), i in 0 to false) seq? :
            if inferred-var?(vt,y) : One([n(y as EVar), i])
            else : None()
        ;Create branches and casts
        for b in branches(ins) map :
          val casts = for [v,i] in var-indices map :
            Cast(v, types(b)[i])
          Branch(n(b), casts)
      (ins:EIf) :
        [Branch(n1(ins), [])
         Branch(n2(ins), [])]
      (ins:ETypeof) :
        if inferred-var?(vt,y(ins)) :
          val v = n(y(ins) as EVar)
          [Branch(n1(ins), [Cast(v,type(ins))])
           Branch(n2(ins), [Cast(v,ETop())])]
        else :
          [Branch(n1(ins), [])
           Branch(n2(ins), [])]
    emit(Match(branches))

  ;Generate the commands for expressions that create a simple result.
  ;Structure:
  ;  Use ...        - All referenced variables
  ;  Wrapped<Ins>   - The original wrapped instruction
  ;  Def            - The new result
  defn gen-simple-result-commands (ins:ETuple|EVoidTuple|EArray|EObject|EBox|
                                       ENewObject|ELetRec|EClosureGet|EObjectGet|
                                       EBoxGet|EInterpret|ELoad|ETupleGet|EPrim|ECall) :
    ;Helper: Emit Def for all inferred variables defined
    ;by this instruction.
    defn emit-def (t:EType) :
      for v in varlocs(ins) do :
        if inferred-var?(vt,v) :
          emit(Def(n(v), t))         

    ;Helper: If the given primitive operation returns a guaranteed reftype
    ;then return it.
    defn op-result-type (op:EOp) -> EType|False :
      match(op) :
        (op:IntAddOp|IntSubOp|IntMulOp|IntDivOp|IntModOp|
            IntAndOp|IntOrOp|IntXorOp|IntNotOp|IntShlOp|
            IntShrOp|IntAshrOp|IntNegOp) :
          core-type(CORE-INT-ID)
        (op:IntLtOp|IntGtOp|IntLeOp|IntGeOp) : 
          EOr(core-type(CORE-FALSE-ID),
              core-type(CORE-TRUE-ID))
        (op) : false
 
    ;Helper: Return true if the return type of the given function
    ;is trusted.
    defn return-type-trusted? (f:Int, arity:Int) -> True|False :
      if trust-declared-types? : true
      else if lostanza?(vt,f) or tail?(vt,f,arity) : false
      else : true

    ;Overall algorithm
    gen-uses(ins)
    emit(Wrapped<EIns>(ins))          
    match(ins) :
      (ins:ETuple|EVoidTuple) : emit-def(core-type(CORE-TUPLE-ID))
      (ins:EArray) : emit-def(EOf(n(ins)))
      (ins:EObject) : emit-def(EOf(n(ins)))
      (ins:EBox) : emit-def(core-type(CORE-BOX-ID))
      (ins:ENewObject) : emit-def(EOf(n(ins)))
      (ins:ELetRec) : emit-def(core-type(CORE-FN-ID))
      (ins:EClosureGet|EObjectGet|EBoxGet|EInterpret|ELoad|ETupleGet) : emit-def(ETop())
      (ins:EPrim) :
        val t = op-result-type(op(ins))
        match(t:EType) : emit-def(t)
        else : emit-def(ETop())
      (ins:ECall) :
        ;Compute return type
        val return-type = let :
          val parts = deconstruct-function(f(ins))
          if not empty?(parts) :
            val [f, targs] = value!(parts)
            val arity = length(ys(ins))
            if return-type-trusted?(f,arity) :
              val [a1, a2] = fn-types(vt, f, arity, targs)
              a2
        ;Emit def
        match(return-type:EType) : emit-def(return-type)
        else : emit-def(ETop())

  ;Generate the commands for expressions that may emit an inherit command.
  ;Structure:
  ;  Use ...        - All referenced variables
  ;  Wrapped<Ins>   - The original wrapped instruction
  ;  Def/Inherit    - The new result
  defn gen-inherit-commands (ins:EDef|EStore) :
    gen-uses(ins)
    emit(Wrapped<EIns>(ins))

    ;Helper: Generate either def/inherit command when assigning
    ;x to the given immediate.
    defn assign (x:Int, y:EImm) :
      match(y:EVar) :
        if inferred-var?(vt,y) : emit(Inherit(x,n(y)))
        else if trust-declared-types? : emit(Def(x,type(vt,y)))
        else : emit(Def(x,trusted-global-type(vt,n(y))))
      else :
        emit(Def(x,type(vt,y)))
    
    match(ins) :
      (ins:EDef) :
        if inferred-var?(vt,x(ins)) :
          match(y(ins)) :
            (y:EImm) : assign(n(x(ins)), y)
            (y:False) : emit(Def(n(x(ins)), EBot()))
      (ins:EStore) :
        if inferred-var?(vt,loc(ins)) :
          val x = n(loc(ins) as EVarLoc)
          assign(x, y(ins))

  ;Generate the commands for expressions.
  ;Structure:
  ;  Wrapped<Ins>  - The original wrapped instruction
  ;  InitCode ...  - The initializing marker
  ;  Def           - The new objects/closures
  defn gen-init-commands (ins:EInitClosures|ENew) :
    emit(Wrapped<EIns>(ins))
    match(ins) :
      (ins:EInitClosures) :
        for x in xs(ins) do :
          emit(InitCode(n(x)))
        for x in xs(ins) do :
          fatal("InitClosures is not an inferred variable.") when not inferred-var?(vt,x)
          emit(Def(n(x), core-type(CORE-FN-ID)))
      (ins:ENew) :
        for n in object-method-table[n(ins)] do :
          emit(InitCode(n))
        fatal("ENew is not an inferred variable.") when not inferred-var?(vt,x(ins))
        emit(Def(n(x(ins)), EOf(n(ins))))
    

  fatal("Not yet implemented")

;<comment>





  ;Trivial commands
  ;Structure:
  ;  Use ...        - All referenced variables
  ;  Wrapped<Ins>   - The original wrapped instruction
  defn gen-trivial-commands (ins:Ins) :
    ???

  ;Helper: If the instruction performs some operation and yields a result
  ;for a potential inferred variable, then return the result type.
  ;The instructions that may emit Inherit commands are not handled here.
  defn result-type? (ins:Ins) -> Maybe<EType> :
    match(ins) :
      (ins:ENew) :
      (ins:EObject) :
      (ins:ETuple|EVoidTuple) : TUPLE-TYPE
      (ins:ETupleGet) : ETop()
      (ins:EArray) : ARRAY-TYPE
      (ins:ECall) :
      (ins:EInterpret) : ETop()
      (ins:EPrim) : op-result-type?(op(ins))
      (ins:EBox) : BOX-TYPE
      (ins:EBoxGet) : ETop()
      (ins:ENewObject) :
      (ins:EObjectGet) : ETop()
      (ins:EClosureGet) : ETop()
      (ins:ELetRec) : FN-TYPE      
      (ins) : None()


  for ins in instructions(b) do :
    ;Utility: Emit instruction as simple wrapped instruction.
    defn emit-as-wrapped () : emit(Wrapped<EIns>(ins))

    ;Scan through each instruction
    match(ins) :
      ;Defining a new variable.
      ;Case: Initialized to a variable.
      ;- Inherit the type if the variable is also an inferred variable.
      ;- Otherwise, type is either the declared type or trusted type. 
      ;Case: Initialized to a literal.
      ;- VarTable can calculate type.
      ;Case: Not initialized.
      ;- Type is bottom.
      (ins:EDef) :
        if inferred-var?(params, x(ins)) :
          val y = y(ins)
          match(y:EImm) :
            if inferred-var?(y) : emit(Inherit(n(x(ins)), n(y as EVar)))
            else : emit(Def(n(x(ins)), inferred-imm-type(y)))
          else : emit(Def(n(x(ins)), EBot()))
            
      ;Initializing closures.
      (ins:EInitClosures) :
        for x in xs(ins) do :
          emit(InitCode(n(x)))

      ;Initializing objects.
      (ins:ENew) :
        for methodn in method-ids(params, n(ins)) do :
          emit(InitCode(methodn))

      ;Creating a tuple
      (ins:ETuple) :
      (ins:EVoidTuple) :

      ;Retrieving from a tuple.
      ;The result has type Top, but the argument is now known
      ;to be a Tuple.
      (ins:ETupleGet) :
      
      ;Assigning to a tuple.
      ;The argument is now known to be a tuple.
      (ins:ETupleSet) :

      ;Creating an object.
      (ins:EObject) :

      ;Creating an array.
      (ins:EArray) :

      ;Structs do not assign to inferred variables.
      (ins:EStruct) :
        fatal("Unexpected inferred variable.") when inferred-var?(params, x(ins))

      ;Ptrs do not assign to inferred variables.
      (ins:EPtr) :
        fatal("Unexpected inferred variable.") when inferred-var?(params, x(ins))

      ;Loading into a local variable.
      ;If we trust the declared type, then the resulting type is 'type'
      ;otherwise it is Top.
      (ins:ELoad) :
        if inferred-var?(params, x(ins)) :
          val type = xtype(ins) when trust-declared-types? else ETop()
          emit(Def(n(x(ins)), type))

      ;Storing into a location.
      ;If we are storing an inferred variable, then inherit it.
      ;Otherwise compute its inferred immediate type.
      (ins:EStore) :
        if inferred-var?(params, loc(ins)) :
          val x = n(loc(ins) as VarLoc)
          if inferred-var?(params, y(ins)) : emit(Inherit(x, n(y(ins) as EVar)))
          else : emit(Def(x, inferred-imm-type(y(ins))))

      ;Simple label.
      (ins:ELabel) : false

      ;Tail call. Return value is not used afterwards, so
      ;does not involve inference.
      (ins:ETCall) : false
      
      ;Function call. Compute return value of call.
      (ins:ECall) :
        ???

      ;Debugging instruction.
      (ins:EDump) : false

      ;Interpret instruction.
      ;Type is Top, if inferred variable.
      (ins:EInterpret) :
        if inferred-var?(params, x(ins)) :
          emit(Def(n(x(ins)), ETop()))

      ;Convert is not used on ref types.
      (ins:EConv) :
        fatal("Unexpected inferred variable.") when inferred-var?(params, x(ins))

      ;Not expected in basic block analysis.
      (ins:EGoto) :
        fatal("Unexpected instruction.")

      ;Compute output type based upon primitive.
      (ins:EPrim) :
        if inferred-var?(params, x(ins)) :
          val type = op-return-type(op(ins))
          match(type:EType) : emit(Def(n(x(ins)), type))
          else : emit(Def(n(x(ins)), ETop()))

      ;If/Match/Dispatch instructions go after the
      ;wrapped instruction. 
      (ins:EIf) : false
      (ins:EMatch) : false
      (ins:EDispatch) : false

      ;Force cast a variable.
      (ins:ECheck) :
        if inferred-var?(params, y(ins)) :
          val v = n(y(ins) as EVar)
          emit(Cast(v, type(ins)))

      ;Creation of a box.
      (ins:EBox) :
        if inferred-var?(x(ins)) :
          emit(Def(n(x(ins)), BOX-TYPE))
      ;Retrieving from a box.
      (ins:EBoxGet) :
        
      (ins:EBoxSet) : false

      (ins:ENewObject) :
      (ins:EObjectGet) :
      (ins:EObjectTGet) :
      (ins:EClosureGet) :
      (ins:EClosureTGet) :
      (ins:ETDef) :
      (ins:ELetRec) :
      (ins:ETypeObject) :
      (ins:EEnd) :
      (ins:ELive) :
      (ins:ETypeof) :
      (ins:ECheckFail) :

      ;No inference instructions.
      (ins:EReturn) : false
      (ins:ECheckLength) : false
      (ins:ECheckSet) :
      


    ;Emit the original instruction wrapped.
    emit(Wrapped<EIns>(ins))
    
;<comment>
;============================================================
;==================== Utilities =============================
;============================================================

