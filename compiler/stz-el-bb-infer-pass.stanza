defpackage stz/el-bb-infer-pass :
  import core
  import collections
  import stz/el-ir
  import stz/dl-ir
  import stz/el-var-table
  import stz/el-bb-infer
  import stz/el
  import stz/basic-ops
  import stz/el-utils

;============================================================
;===================== Main Driver ==========================
;============================================================

public defn construct-code (epackage:EPackage, gvt:VarTable) -> Code :
  defn process-body (b:EBody, vt:VarTable) :
    fatal("Process Body")
  defn process-fn (f:EFn, vt:VarTable) :
    construct-code(-1, args(f), a1(f), body(f), free(f))
    fatal("Process fn")
  defn process (texp:ELBigItem, vt:VarTable) -> ELBigItem :
    match(texp) :
      (texp:EBody) : process-body(texp, vt)
      (texp:EFn) : process-fn(texp, vt)
      (texp) : map(process{_, vt}, texp)


  within (texp, vt) = map-with-var-table(gvt, epackage) :
    val texp* = analyze-freevars(texp, vt)
    process(texp*, vt) as ETExp

  fatal("Not yet implemented")

defn construct-code (n:Int, args:Tuple<Int>, a1:Tuple<EType>, body:EBody, free:Free) -> Code : 
  defn analyze-block (block:BBlock) -> Block :
    println("Analyzing block %_" % [lbl(block)])
    do(println, instructions(block))
    fatal("Not yet implemented")

  ;Get the basic blocks
  val bbtable = analyze-basic-blocks(ins(body))
  do(analyze-block, bbtable)

  fatal("Not yet implemented")

defn map-with-var-table (f:(ETExp, VarTable) -> ETExp, gvt:VarTable, epackage:EPackage) -> EPackage :
  val exps* = for e in exps(epackage) map :
    f(e, LocalVarTable(gvt, e))
  sub-exps(epackage, exps*)

;============================================================
;==================== Utilities =============================
;============================================================

;Return true if the given variable refers to a
;variable that is handled by the inference engine.
;Variables must be local, and have a reftype. 
defn inferred-var? (vt:VarTable, n:Int) -> True|False :
  val record = vt[n]
  if not global?(record) :
    match(entry(record)) :
      ;Local functions are always simple closures.
      (e:FnEntry) : true 
      (e:VarEntry) : reftype?(type(e) as EType)

;Return true if the given immediate refers to a
;inferred variable in the inference engine.
defn inferred-var? (vt:VarTable, y:EImm) -> True|False :
  match(y:EVar) :
    inferred-var?(vt, n(y))

;Return true if the given variable location refers
;to an inferred variable in the inference engine.
defn inferred-var? (vt:VarTable, x:ELoc) -> True|False :
  match(x:EVarLoc) :
    inferred-var?(vt, n(x))

;Return the trusted type of the given global variable.
;It is assumed that the global variable has a reftype.
defn trusted-global-type (vt:VarTable, n:Int) -> EType :
  fatal("Not a global") when not global?(vt,n)
  if variable?(vt,n) :
    val t = type(vt,n)
    fatal("Not a reftype") when not reftype?(t)
    if lostanza?(vt,n) : ETop() ;Do not trust declared types of LoStanza variables.
    else : t                    ;Trust declared types of HiStanza variables.
  else if lostanza?(vt,n) :
    ;Ensure that the function can be used as a closure.
    val t = type(vt,n) as EFnT
    fatal("Cannot be a closure.") when r(t) is-not False
    fatal("Cannot be a closure.") when not all?(reftype?,a(t))
    fatal("Cannot be a closure.") when not reftype?(b(t))    
    ;Global functions just have type Fn
    EOf(/n(iotable(vt), CORE-FN-ID))
  else :
    ;Global functions just have type Fn
    EOf(/n(iotable(vt), CORE-FN-ID))

;============================================================
;================ Single Block Analysis =====================
;============================================================

;Generate inference commands for a single block.
;- emit: is called for every generated inference command.
;- block: is the block to analyze.
;- vt: is the local VarTable for the current top-level expression.
;- object-method-table: Holds the identifiers of all object methods.
;- trust-declared-types?: If true indicates that we should trust
;  the declared types of functions and global variables.
defn analyze-single-block (emit:Ins -> ?,
                           block:BBlock,
                           vt:VarTable,
                           object-method-table:IntTable<Tuple<Int>>,
                           trust-declared-types?:True|False) :
  ;Overall algorithm for the different classes of instructions.
  ;  Cast commands: ECheck
  ;  Match commands: EMatch|EDispatch|EIf|ETypeof
  ;  Simple result commands: ETuple|EVoidTuple|EArray|EObject|EBox|
  ;                          ENewObject|ELetRec|EClosureGet|EObjectGet|
  ;                          EBoxGet|EInterpret|ELoad|ETupleGet|EPrim|ECall
  ;  Inherit commands: EDef|EStore
  ;  Initcode commands: EInitClosures|ENew
  ;  Trivial commands: ETupleSet|EStruct|EPtr|ELabel|ETCall|
  ;                    EDump|EConv|EGoto|ECheckLength|ECheckSet|
  ;                    EBoxSet|EReturn|EObjectTGet|EClosureTGet|
  ;                    ETDef|ETypeObject|EEnd|ELive|ECheckFail
  defn gen-commands (ins:EIns) :
    match(ins) :
      (ins:ECheck) : gen-cast-commands(ins)
      (ins:EMatch|EDispatch|EIf|ETypeof) : gen-match-commands(ins)
      (ins:ETuple|EVoidTuple|EArray|EObject|EBox|
           ENewObject|ELetRec|EClosureGet|EObjectGet|
           EBoxGet|EInterpret|ELoad|ETupleGet|EPrim|ECall) : gen-simple-result-commands(ins)
      (ins:EDef|EStore) : gen-inherit-commands(ins)
      (ins:EInitClosures|ENew) : gen-init-commands(ins)
      (ins:ETupleSet|EStruct|EPtr|ELabel|ETCall|
           EDump|EConv|EGoto|ECheckLength|ECheckSet|
           EBoxSet|EReturn|EObjectTGet|EClosureTGet|
           ETDef|ETypeObject|EEnd|ELive|ECheckFail) : gen-trivial-commands(ins)

  ;Utility: For any uses of inferred variables generate
  ;them here.
  defn gen-uses (ins:EIns) :
    for y in uses(ins) do :
      emit(Use(n(y as EVar))) when inferred-var?(vt,y)

  ;Utility: Retrieve the core type with the given id.
  defn core-type (id:TypeId) -> EOf :
    EOf(n(iotable(vt), id))

  ;Generate the commands for a cast command.
  ;Structure:
  ;  Use ...       - All referenced variables
  ;  Wrapped<Ins>  - The original wrapped instruction
  ;  Cast          - The cast command
  defn gen-cast-commands (ins:ECheck) :
    gen-uses(ins)
    if inferred-var?(vt,y(ins)) :
      val v = n(y(ins) as EVar)
      emit(Cast(v, type(ins)))
    emit(Wrapped<EIns>(ins))

  ;Generate the commands for a match command.
  ;Structure:
  ;  Use ...       - All referenced variables
  ;  Wrapped<Ins>  - The original wrapped instruction
  ;  Match         - The match command 
  defn gen-match-commands (ins:EMatch|EDispatch|EIf|ETypeof) :
    gen-uses(ins)
    emit(Wrapped<EIns>(ins))
    val branches = match(ins) :
      (ins:EMatch|EDispatch) :
        ;Each entry, [v, i], in var-indices indicates that
        ;variable v is an inferred variable and is argument i
        ;in the match.
        val var-indices = to-tuple $
          for (y in ys(ins), i in 0 to false) seq? :
            if inferred-var?(vt,y) : One([n(y as EVar), i])
            else : None()
        ;Create branches and casts
        for b in branches(ins) map :
          val casts = for [v,i] in var-indices map :
            Cast(v, types(b)[i])
          Branch(n(b), casts)
      (ins:EIf) :
        [Branch(n1(ins), [])
         Branch(n2(ins), [])]
      (ins:ETypeof) :
        if inferred-var?(vt,y(ins)) :
          val v = n(y(ins) as EVar)
          [Branch(n1(ins), [Cast(v,type(ins))])
           Branch(n2(ins), [Cast(v,ETop())])]
        else :
          [Branch(n1(ins), [])
           Branch(n2(ins), [])]
    emit(Match(branches))

  ;Generate the commands for expressions that create a simple result.
  ;Structure:
  ;  Use ...        - All referenced variables
  ;  Wrapped<Ins>   - The original wrapped instruction
  ;  Def            - The new result
  defn gen-simple-result-commands (ins:ETuple|EVoidTuple|EArray|EObject|EBox|
                                       ENewObject|ELetRec|EClosureGet|EObjectGet|
                                       EBoxGet|EInterpret|ELoad|ETupleGet|EPrim|ECall) :
    ;Helper: Emit Def for all inferred variables defined
    ;by this instruction.
    defn emit-def (t:EType) :
      for v in varlocs(ins) do :
        if inferred-var?(vt,v) :
          emit(Def(n(v), t))         

    ;Helper: If the given primitive operation returns a guaranteed reftype
    ;then return it.
    defn op-result-type (op:EOp) -> EType|False :
      match(op) :
        (op:IntAddOp|IntSubOp|IntMulOp|IntDivOp|IntModOp|
            IntAndOp|IntOrOp|IntXorOp|IntNotOp|IntShlOp|
            IntShrOp|IntAshrOp|IntNegOp) :
          core-type(CORE-INT-ID)
        (op:IntLtOp|IntGtOp|IntLeOp|IntGeOp) : 
          EOr(core-type(CORE-FALSE-ID),
              core-type(CORE-TRUE-ID))
        (op) : false
 
    ;Helper: Return true if the return type of the given function
    ;is trusted.
    defn return-type-trusted? (f:Int, arity:Int) -> True|False :
      if trust-declared-types? : true
      else if lostanza?(vt,f) or tail?(vt,f,arity) : false
      else : true

    ;Overall algorithm
    gen-uses(ins)
    emit(Wrapped<EIns>(ins))          
    match(ins) :
      (ins:ETuple|EVoidTuple) : emit-def(core-type(CORE-TUPLE-ID))
      (ins:EArray) : emit-def(EOf(n(ins)))
      (ins:EObject) : emit-def(EOf(n(ins)))
      (ins:EBox) : emit-def(core-type(CORE-BOX-ID))
      (ins:ENewObject) : emit-def(EOf(n(ins)))
      (ins:ELetRec) : emit-def(core-type(CORE-FN-ID))
      (ins:EClosureGet|EObjectGet|EBoxGet|EInterpret|ELoad|ETupleGet) : emit-def(ETop())
      (ins:EPrim) :
        val t = op-result-type(op(ins))
        match(t:EType) : emit-def(t)
        else : emit-def(ETop())
      (ins:ECall) :
        ;Compute return type
        val return-type = let :
          val parts = deconstruct-function(f(ins))
          if not empty?(parts) :
            val [f, targs] = value!(parts)
            val arity = length(ys(ins))
            if return-type-trusted?(f,arity) :
              val [a1, a2] = fn-types(vt, f, arity, targs)
              a2
        ;Emit def
        match(return-type:EType) : emit-def(return-type)
        else : emit-def(ETop())

  ;Generate the commands for expressions that may emit an inherit command.
  ;Structure:
  ;  Use ...        - All referenced variables
  ;  Wrapped<Ins>   - The original wrapped instruction
  ;  Def/Inherit    - The new result
  defn gen-inherit-commands (ins:EDef|EStore) :
    gen-uses(ins)
    emit(Wrapped<EIns>(ins))

    ;Helper: Generate either def/inherit command when assigning
    ;x to the given immediate.
    defn assign (x:Int, y:EImm) :
      match(y:EVar) :
        if inferred-var?(vt,y) : emit(Inherit(x,n(y)))
        else if trust-declared-types? : emit(Def(x,type(vt,y)))
        else : emit(Def(x,trusted-global-type(vt,n(y))))
      else :
        emit(Def(x,type(vt,y)))
    
    match(ins) :
      (ins:EDef) :
        if inferred-var?(vt,x(ins)) :
          match(y(ins)) :
            (y:EImm) : assign(n(x(ins)), y)
            (y:False) : emit(Def(n(x(ins)), EBot()))
      (ins:EStore) :
        if inferred-var?(vt,loc(ins)) :
          val x = n(loc(ins) as EVarLoc)
          assign(x, y(ins))

  ;Generate the commands for expressions.
  ;Structure:
  ;  Wrapped<Ins>  - The original wrapped instruction
  ;  InitCode ...  - The initializing marker
  ;  Def           - The new objects/closures
  defn gen-init-commands (ins:EInitClosures|ENew) :
    emit(Wrapped<EIns>(ins))
    match(ins) :
      (ins:EInitClosures) :
        for x in xs(ins) do :
          emit(InitCode(n(x)))
        for x in xs(ins) do :
          fatal("InitClosures is not an inferred variable.") when not inferred-var?(vt,x)
          emit(Def(n(x), core-type(CORE-FN-ID)))
      (ins:ENew) :
        for n in object-method-table[n(ins)] do :
          emit(InitCode(n))
        fatal("ENew is not an inferred variable.") when not inferred-var?(vt,x(ins))
        emit(Def(n(x(ins)), EOf(n(ins))))

  ;Generate the commands for trivial expressions.
  ;Structure:
  ;  Uses ...       - All referenced variables
  ;  Wrapped<Ins>   - The original wrapped instruction
  defn gen-trivial-commands (ins:ETupleSet|EStruct|EPtr|ELabel|ETCall|
                                 EDump|EConv|EGoto|ECheckLength|ECheckSet|
                                 EBoxSet|EReturn|EObjectTGet|EClosureTGet|
                                 ETDef|ETypeObject|EEnd|ELive|ECheckFail) :
    gen-uses(ins)
    emit(Wrapped<EIns>(ins))
    for x in varlocs(ins) do :
      if inferred-var?(vt,x) :
        fatal("Unexpected inferred variable %_ in instruction %_." % [x, ins])

  ;Launch!
  do(gen-commands, instructions(block))    

;============================================================
;==================== Utilities =============================
;============================================================

