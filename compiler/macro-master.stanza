defpackage stz/macro-master :
  import core
  import collections
  import core/dynamic-library
  import stz/fastio-runtime
  import stz/plugin-interface
  import stz/sexp-serializer
  import stz/sexp-checker

;============================================================
;========================= API ==============================
;============================================================

;Represents a loaded macro plugin.
public deftype MacroPlugin

;Expand the given s-expressions.
public defmulti macroexpand (p:MacroPlugin, form, overlays:List<Symbol>) -> ?

;Check whether the syntax package exists.
public defmulti syntax-package-exists? (p:MacroPlugin, name:Symbol) -> True|False

;============================================================
;==================== Loading a Plugin ======================
;============================================================

;Load a macro plugin from a file.
public defn load-macro-plugin (filename:String) -> MacroPlugin :
  ;Load the macro dynamic library.
  val lib =
    try :
      dynamic-library-open(ensure-slash(filename))
    catch (e) :
      throw(ErrorLoadingMacroPlugin(filename, e))

  ;Test that it's a valid macro plugin
  test-validity(lib)

  ;Call its main function for initialization.
  call-main(lib)

  ;Create the interface for communicating with it.
  val interface = PluginInterface(SExpIO())

  ;Create the plugin
  new MacroPlugin :
    defmethod macroexpand (this, form, overlays:List<Symbol>) -> ? :
      check-valid-sexp(form)
      call-entry(interface, lib, "macroexpand", [form, overlays])
    defmethod syntax-package-exists? (this, name:Symbol) -> True|False :
      call-entry(interface, lib, "check_syntax_package_exists", name)

;============================================================
;===================== Ensure Slash =========================
;============================================================

;dlopen treats filenames that contain no slashes separately. If
;a raw name like "gzip" is provided, dlopen will begin a
;sophisticated system-wide search procedure to look for a
;compatible library named "gzip". Instead, we want to support
;only file paths (absolute or relative), so "gzip" should be
;preprocessed into "./gzip". 

defn ensure-slash (filename:String) -> String :
  if contains?(filename, '/') :
    filename
  else :
    string-join(["./", filename])

;============================================================
;==================== Sanity Handshake ======================
;============================================================

;Test validity of the loaded library.
defn test-validity (lib:DynamicLibrary) -> False :
  val result =
    try :
      val sym = dynamic-library-symbol(lib, "handshake")
      call-handshake(sym)
    catch (e) :
      throw(InvalidMacroPlugin(name(lib)))

  if result != 0xcafebabe :
    throw(InvalidMacroPlugin(name(lib)))

;Call the given handshake function.
lostanza defn call-handshake (sym:ref<DynamicSymbol>) -> ref<Int> :
  val f = sym.address as ptr<(() -> int)>
  val result = call-c [f]()
  return new Int{result}

;============================================================
;======================= Errors =============================
;============================================================

;Occurs when the call to dlopen fails.
public defstruct ErrorLoadingMacroPlugin <: Exception :
  filename: String
  error: Exception

defmethod print (o:OutputStream, e:ErrorLoadingMacroPlugin) :
  print(o, "Failed to load macro plugin from %~:\n%_" % [
    Indented(error(e))])

;Occurs when the macro fails to satisfy the sanity
;handshake.
public defstruct InvalidMacroPlugin <: Exception :
  filename:String

defmethod print (o:OutputStream, e:InvalidMacroPlugin) :
  print(o, "File %~ is not a valid macro plugin." % [filename(e)])