#use-added-syntax(stz-serializer-lang)
defpackage stz/defs-db-serializer :
  import core
  import collections
  import stz/serializer
  import stz/visibility

;===============================================================================
; =============================== Types ========================================
;===============================================================================
doc: "Represents the kind of item associated with a definition"
public defenum SrcDefinitionKind : 
  SrcDefUnknown
  SrcDefMulti 
  SrcDefMethod 
  SrcDefFunction 
  SrcDefVariable
  SrcDefType
  SrcDefPackage

doc: "Represents whether the definition was found in a source file or pkg"
public public defenum SrcDefinitionSource : 
  PkgDefinition 
  SrcDefinition

doc: "A single defined item"
public defstruct Definition <: Equalable : 
  name:Symbol
  file-info:FileInfo 
  kind:SrcDefinitionKind 
  source:SrcDefinitionSource
  pkg-name:Symbol
  visibility:Visibility
  annotation?:False|DefinitionAnnotation

doc: "A collection of definitions and reserved words in a stanza project"
public defstruct DefinitionsDatabase : 
  reserved-words:Tuple<String>
  definitions:HashTable<Symbol, List<Definition>>
  packages:Tuple<PackageDefinition>

doc: "A definition of a package and its imports."
public defstruct PackageDefinition : 
  name:Symbol
  file-name:String
  imports:Tuple<PackageImport>

doc: "An imported package and its prefixes."
public defstruct PackageImport : 
  name:Symbol
  prefixes:Tuple<PackageImportPrefix>

doc: "A prefix in a package import."
public defstruct PackageImportPrefix : 
  names:False|Tuple<Symbol>
  prefix:String

doc: "A DefinitionAnnotation is some definition-specific \
      metadata that is useful for tooling, for example   \
      function signatures."
public deftype DefinitionAnnotation <: Equalable

doc: "Annotations given to defn objects."
public defstruct DefnAnnotation <: DefinitionAnnotation :
  args:Tuple<FnArgAnnotation>
  return-type?:Symbol|False

doc: "A single function argument."
public defstruct FnArgAnnotation <: Equalable :
  name?:Symbol|False
  type?:Symbol|False

;===============================================================================
; =========================== Serializers =====================================
;===============================================================================
public defserializer (out:OutputStream, in:InputStream) : 
  defunion definitions-database (DefinitionsDatabase) :
    DefinitionsDatabase : (reserved-words:tuple(string), definitions:table, packages:tuple(package-definition))

  defunion definition (Definition) : 
    Definition : (name:symbol, file-info:fileinfo, kind:src-def-kind, source:src-def-src, pkg-name:symbol, visibility:visibility, annotation?:opt<DefinitionAnnotation>(annotation))
  
  defunion package-definition (PackageDefinition) : 
    PackageDefinition : (name:symbol, file-name:string, imports:tuple(package-import))

  defunion package-import (PackageImport) : 
    PackageImport : (name:symbol, prefixes:tuple(package-import-prefix))

  defunion package-import-prefix (PackageImportPrefix) : 
    PackageImportPrefix : (names:opt<Tuple<Symbol>>(tuple(symbol)), prefix:string)
  
  defunion fileinfo (FileInfo) :
    FileInfo : (filename:string, line:int, column:int)

  defunion fn-arg-annotation (FnArgAnnotation) : 
    FnArgAnnotation : (name?:opt<Symbol>(symbol), type?:opt<Symbol>(symbol))
  
  defunion annotation (DefinitionAnnotation) : 
    DefnAnnotation : (args:tuple(fn-arg-annotation), return-type?:opt<Symbol>(symbol))

  reader defn read-visibility () : 
    Visibility(read-int())

  writer defn write-visibility (v:Visibility) : 
    write-int(to-int(v))

  reader defn read-table () :
    val n = read-int()
    to-hashtable<Symbol, List<Definition>> $ 
      for i in 0 to n seq : read-symbol() => read-list(read-definition)

  writer defn write-table (tbl:HashTable<Symbol, List<Definition>>) :
    write-int(length(tbl))
    for e in tbl do :
      write-symbol(key(e))
      write-list(write-definition, value(e))

  reader defn read-list<?T> (f: () -> ?T) :
    val n = read-int()
    to-list(repeatedly(f, n))

  writer defn write-list<?T> (f: T -> False, xs:List<?T>) :
    write-int(length(xs))
    do(f, xs)
  
  reader defn read-tuple<?T> (f: () -> ?T) :
    val n = read-int()
    to-tuple(repeatedly(f, n))

  writer defn write-tuple<?T> (f: T -> False, xs:Tuple<?T>) :
    write-int(length(xs))
    do(f, xs)

  reader defn read-opt<T> (f: () -> T) :
    val n = read-byte()
    f() when n == 1Y

  writer defn write-opt<T> (f: T -> False, x:T|False) :
    match(x) :
      (x:False) :
        write-byte(0Y)
      (x:T) :
        write-byte(1Y)
        f(x)

  defatom src-def-src (x:SrcDefinitionSource): 
    writer: 
      write-int(to-int(x))
    reader : 
      val i = read-int()
      if (i < 0) or (i >= SrcDefinitionSource-length) : 
        throw(DeserializeException())
      SrcDefinitionSource(i)

  defatom src-def-kind (x:SrcDefinitionKind) :
    writer :
      write-int(to-int(x))
    reader :
      val i = read-int()
      if i < 0 or i >= SrcDefinitionKind-length :
        throw(DeserializeException())
      SrcDefinitionKind(i)
  
  defatom symbol (x:Symbol) :
    writer :
      write-string(to-string(x))
    reader :
      to-symbol(read-string())

  defatom byte (x:Byte) :
    writer :
      put(out, x)
    reader :
      match(get-byte(in)) :
        (x:Byte) : x
        (x:False) : throw(DeserializeException())

  defatom char (x:Char) :
    writer :
      print(out, x)
    reader :
      match(get-char(in)) :
        (x:Char) : x
        (x:False) : throw(DeserializeException())

  defatom string (x:String) :
    writer :
      write-int(length(x))
      print(out, x)
    reader :
      val n = read-int()
      String(repeatedly(read-char, n))

  defatom int (x:Int): 
    writer: 
      to-var-int(x, put{out, _})
    reader:
      from-var-int(read-byte)

public defn read-definitions-database (in:InputStream) -> DefinitionsDatabase : 
  deserialize-definitions-database(in) as DefinitionsDatabase

defn to-var-int (x:Int, Y: Byte -> False) :
  defn B0 (x:Int) : Y(to-byte(x))
  defn B1 (x:Int) : Y(to-byte(x >> 8))
  defn B2 (x:Int) : Y(to-byte(x >> 16))
  defn B3 (x:Int) : Y(to-byte(x >> 24))
  if x >= 0 :
    if x < 250 : B0(x)
    else if x < 506 : (Y(250Y), B0(x - 250))
    else if x < 762 : (Y(251Y), B0(x - 506))
    else if x < 1018 : (Y(252Y), B0(x - 762))
    else if x < 32768 : (Y(253Y), B1(x), B0(x))
    else if x < 8388608 : (Y(254Y), B2(x), B1(x), B0(x))
    else : (Y(255Y), B3(x), B2(x), B1(x), B0(x))
  else :
    if x >= -32768 : (Y(253Y), B1(x), B0(x))
    else if x >= -8388608 : (Y(254Y), B2(x), B1(x), B0(x))
    else : (Y(255Y), B3(x), B2(x), B1(x), B0(x))

defn from-var-int (N: () -> Byte) -> Int :
  defn B0 () : to-int(N())
  defn B1 () : B0() << 8
  defn B2 () : B0() << 16
  defn S1 () : (B0() << 24) >>> 16
  defn S2 () : (B0() << 24) >>> 8
  defn S3 () : (B0() << 24)

  val x = N()
  switch(x) :
    255Y : S3() | B2() | B1() | B0()
    254Y : S2() | B1() | B0()
    253Y : S1() | B0()
    252Y : B0() + 762
    251Y : B0() + 506
    250Y : B0() + 250
    else : to-int(x)

defmethod equal? (l:Definition, r:Definition) :
  name(l)        == name(r)       and 
  file-info(l)   == file-info(r)  and  
  kind(l)        == kind(r)       and  
  source(l)      == source(r)     and 
  pkg-name(l)    == pkg-name(r)   and 
  visibility(l)  == visibility(r) and
  annotation?(l) == annotation?(r)

defmethod equal? (l:DefnAnnotation, r:DefnAnnotation) : 
  return-type?(l) == return-type?(r) and 
  for (larg in args(l), rarg in args(r)) all? : 
    larg == rarg

defmethod equal? (l:FnArgAnnotation, r:FnArgAnnotation) : 
  name?(l) == name?(r) and 
  type?(l) == type?(r)

;===============================================================================
;============================== Printers =======================================
;===============================================================================
defmethod print (o:OutputStream, def:Definition):
  print(o, "Definition %_ defined at %_:" % [name(def), file-info(def)])
  val oo = IndentedStream(o)
  lnprint(oo, "kind: %_" % [kind(def)])
  lnprint(oo, "source: %_" % [source(def)])
  lnprint(oo, "pkg-name: %_" % [pkg-name(def)])
  lnprint(oo, "visibility: %_" % [visibility(def)])
  lnprint(oo, "annotation?: %_" % [annotation?(def)])

defmethod print (o:OutputStream, ddb:DefinitionsDatabase):
  val o2 = IndentedStream(o)
  print(o,"Reserved Words:")
  do(lnprint{o2, _}, reserved-words(ddb))
  lnprint(o, "Definitions:")
  do(lnprint{o2, _}, definitions(ddb))

defmethod print (o:OutputStream, a:FnArgAnnotation) : 
  match(name?(a), type?(a)) : 
    (n:Symbol, t:False)  : print(o, n)
    (n:False,  t:Symbol) : print(o, "_:%_" % [t])
    (n:Symbol, t:Symbol) : print(o, "%_:%_" % [n, t])
    (n:False,  t:False)  : false
  
defmethod print (o:OutputStream, f:DefnAnnotation) : 
  print(o, "(%,)" % [args(f)])
  val return-type? = return-type?(f)
  match(return-type?:Symbol) : 
    print(o, " -> %_" % [return-type?])
