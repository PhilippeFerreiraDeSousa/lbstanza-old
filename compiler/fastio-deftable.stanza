defpackage stz/fastio-deftable :
  import core
  import collections
  import stz/fastio-serializer-lang

;============================================================
;======================== API ===============================
;============================================================

;Represents a table of definitions.
public deftype DefTable

;Retrieve the type of a specification.
public defmulti type (t:DefTable, s:IOSpec) -> ?

;Retrieve the definition with the given name.
public defmulti get (t:DefTable, name:Symbol) -> TopExp

;Add a new definition to the DefTable. 
public defmulti add (t:DefTable, e:TopExp) -> False

;============================================================
;=================== Implementation =========================
;============================================================

;Create the DefTable for a serializer.
public defn DefTable (s:DefSerializer) -> DefTable :

  ;Generate table of definitions.
  val table = HashTable<Symbol,TopExp>()

  ;Add the given expression to the table.
  defn add-to-table (e:TopExp) :
    match(e) :
      (e:DefAtom) : table[name(e)] = e
      (e:DefType) : table[name(e)] = e
      (e:DefUnion) : table[name(e)] = e
      (e:DefCombinator) : table[name(e)] = e
      (e) : false

  ;Lookup the type of a spec
  defn spec-type (s:IOSpec) -> ? :
    match(s) :
      (s:NamedSpec) :
        match(table[name(s)]) :
          (e:DefAtom|DefType|DefUnion) : type(e)
          (e:DefCombinator) : fatal("Direct reference to DefCombinator.")
      (s:CastedSpec) :
        type(s)
      (s:CombinatorSpec) :
        val arg-types = map(spec-type, specs(s))
        val c = table[name(s)] as DefCombinator
        sub-arg-types(type(c), args(c), arg-types)

  ;Helper: Given the concrete types for the arguments,
  ;return the final type of the combinator.
  defn sub-arg-types (type, args:Tuple<CombinatorArg>, arg-types:Tuple) -> ? :
    val type-table = to-hashtable<Symbol,?> $
      for (arg in args, type in arg-types) seq :
        type-binder(arg) => type
    sub-in-form(type, type-table)

  ;Return the structure
  do(add-to-table, exps(s))
  new DefTable :
    defmethod type (this, s:IOSpec) :
      spec-type(s)
    defmethod get (this, name:Symbol) :
      table[name]
    defmethod add (this, e:TopExp) :
      add-to-table(e)

;Perform substitutions in given form.
defn sub-in-form (x, table:HashTable<Symbol,?>) -> ? :
  defn recur (x) -> ? :
    match(x) :
      (x:Token) : Token(recur(item(x)), info(x))
      (x:List) : map(recur, x)
      (x:Symbol) : get?(table, x, x)
      (x) : x
  recur(x)