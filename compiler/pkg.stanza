;See License.txt for details about licensing
;#use-added-syntax(stz-serializer-lang)

defpackage stz/pkg :
  import core
  import collections
  import stz/algorithms
  import stz/params
  import stz/serializer
  import stz/utils
  import stz/typeset
  import stz/asm-ir with :
    prefix(AddOp, SubOp, MulOp, DivOp, ModOp, AndOp, OrOp, XorOp, ShlOp,
           ShrOp, AshrOp, EqOp, NeOp, LtOp, GtOp, LeOp, GeOp, UleOp,
           UltOp, UgtOp, UgeOp, NotOp, NegOp, DivModOp, BitSetOp, BitNotSetOp, LowestZeroBitCountOp,
           TestBitOp, TestAndSetBitOp, TestAndClearBitOp, SetBitOp, ClearBitOp,
           TypeofOp, XchgIns, SetIns, ConvertIns, InterpretIns, UnaOp, BinOp, VoidBinOp,
           DualOp, Load, Store, Call, Return, Goto, Break, Label, LinkLabel,
           ExLabel, Match, Dispatch, MethodDispatch, DefData, DefText, DefDirectives, DefExportLabel, DefByte,
           DefInt, DefLong, DefFloat, DefDouble, DefString, DefBytes, DefSpace, DefLabel, Comment) => asm-
  import stz/visibility
  import stz/dl-ir
  import stz/basic-ops
  import stz/vm-ir
  import stz/el-ir
  import core/parsed-path
  import core/stack-trace
  import stz/pkg-ir
  import stz/timing-log-api
  import stz/fastio-errors
  import stz/pkg-errors
  import stz/pkg-serializer

;<doc>=======================================================
;====================== Interface ===========================
;============================================================

# Fundamental State #

  pkg-table: HashTable<Symbol, Pkg>
  filename-table: HashTable<Symbol,String>

Pkg-table holds all loaded Pkg datastructures, indexed by package
name. The source file that the pkg was loaded from are stored in the
filename-table.

# Load a Pkg file by filename #

  load-pkg (loader:PkgLoader, filename:String) -> Pkg

Load in a package given its filename. Ensures that the loaded Pkg is
of the right type given the PkgLoader.

# Load a Pkg file by package name #

  load-pkg (loader:PkgLoader, name:Symbol) -> Pkg

Load in a package given its package name. Ensures that the loaded Pkg
is of the right type given the PkgLoader.

# Load Dependencies #

  load-dependencies (loader:PkgLoader, already-loaded:Seqable<Symbol>) -> False

For all the loaded pkgs, transitively load the pkgs corresponding to
all of their imported dependencies, excluding the packages that are
given as already loaded in some other form. The packages loaded from
the source files will be typically passed here.

# Return all loaded pkgs #

  pkgs (loader:PkgLoader) -> Tuple<Pkg>

Return all the pkgs loaded through the PkgLoader.

# Return the filename that a specific package was loaded from #

  source-file (loader:PkgLoader, name:Symbol) -> String

Assumes that the package was loaded using the given package loader.

# Save a given package to file #

  save-package (dir:String, p:Pkg)-> False

Saves the given package to the given directory.

;============================================================
;=======================================================<doc>

;============================================================
;==================== Timers ================================
;============================================================

val READ-PACKAGE = TimerLabel("Read Package")

;============================================================
;====================== PkgLoader ===========================
;============================================================
;<comment>
public deftype PkgLoader
public defmulti load-pkg (loader:PkgLoader, filename:String) -> Pkg
public defmulti load-pkg (loader:PkgLoader, name:Symbol) -> Pkg
public defmulti load-dependencies (loader:PkgLoader, already-loaded:Seqable<Symbol>) -> False
public defmulti pkgs (loader:PkgLoader) -> Tuple<Pkg>
public defmulti source-file (loader:PkgLoader, name:Symbol) -> String

public defn PkgLoader (optimized?:True|False) :
  val pkg-table = HashTable<Symbol,Pkg>()
  val filename-table = HashTable<Symbol,String>()
  defn add-pkg (pkg:Pkg, filename:String) :
    pkg-table[name(pkg)] = pkg
    filename-table[name(pkg)] = filename

  new PkgLoader :
    defmethod load-pkg (this, filename:String) :
      val pkg = load-package(filename, false, optimized?)
      add-pkg(pkg, filename)
      pkg

    defmethod load-pkg (this, name:Symbol) :
      within update?(pkg-table, name) :
        match(find-pkg(name, optimized?)) :
          (filename:String) :
            val pkg = load-package(filename, name, optimized?)
            add-pkg(pkg, filename)
            pkg
          (_:False) :
            throw(NoPackageException(name))

    defmethod source-file (this, name:Symbol) :
      filename-table[name]

    defmethod load-dependencies (this, already-loaded:Seqable<Symbol>) :
      val loadset = to-hashset<Symbol>(already-loaded)
      defn ensure-loaded (name:Symbol) :
        if not loadset[name] and not key?(pkg-table, name) :
          ensure-dependencies-loaded(load-pkg(this, name))
      defn ensure-dependencies-loaded (pkg:Pkg) :
        do(ensure-loaded, imported-packages(packageio(pkg)))
      do(ensure-dependencies-loaded, to-tuple(values(pkg-table)))

    defmethod pkgs (this) :
      to-tuple(values(pkg-table))
;<comment>
;============================================================
;=================== Package IO =============================
;============================================================

public defn save-package (dir:String, p:Pkg) -> String :
  val pkg-file = string-join([mangle-as-filename(name(p)), extension(p)])
  val filename = to-string(relative-to-dir(parse-path(dir), pkg-file))
  ;val f = FileOutputStream(filename)
  try : serialize-pkg(filename, p)
  catch (e:IOException|FastIOError) : throw(PackageWriteException(filename))
  ;finally : close(f)
  filename

public defn load-package (filename:String,
                          expected-name:Symbol|False,
                          optimized?:True|False,
                          include-asm?:True|False) :
  ;Sanity check
  if optimized? and not include-asm? :
    fatal("Invalid option: Optimized .pkg files always include asm instructions.")

  val event-name = to-string("Read Package: file = %_, expected-name = %_, optimized? = %_" % [
    filename, expected-name, optimized?])
  within log-time(READ-PACKAGE, event-name) :
    ;Load in the package
    ;val f = FileInputStream(filename)
    val pkg =
      try :
        if include-asm? :
          deserialize-pkg(filename)
        else :
          deserialize-repl-pkg(filename)
      catch (e:WrongPkgVersion) :
        throw(sub-filename(e, filename))
      catch (e:FastIOError|IOException) :
        throw(PackageReadException(filename))
    ;  finally : close(f)
    ;Ensure that name and optimization levels match expected.
    match(expected-name:Symbol) :
      ensure-expected-name!(pkg, filename, expected-name)
    ensure-expected-optimization!(pkg, filename, optimized?)
    ;Return the pkg
    pkg

defn ensure-expected-name! (pkg:Pkg, filename:String, name:Symbol) :
  if /name(pkg) != name :
    throw(WrongPackageNameException(filename, name, /name(pkg)))

defn ensure-expected-optimization! (pkg:Pkg, filename:String, optimized?:True|False) :
  val pkg-optimized? = pkg is FastPkg
  if pkg-optimized? != optimized? :
    throw(WrongPackageOptimization(name(pkg), filename, pkg-optimized?, optimized?))  

;============================================================
;===================== Pkg Search ===========================
;============================================================

public defn find-pkg! (name:Symbol, optimized?:True|False) -> String :
  val filename = find-pkg(name, optimized?)
  match(filename:String) : filename
  else : throw(NoPackageException(name))

public defn find-pkg (name:Symbol, optimized?:True|False) -> String|False :
  val mangled = mangle-as-filename(name)
  label<String|False> return :
    ;Check functions
    defn check-file (filename:String) :
      return(filename) when file-exists?(filename)
    defn check-dir (dir:String) :
      val extension = ".fpkg" when optimized? else ".pkg"
      val pkgfile = string-join([mangle-as-filename(name), extension])
      val filename = to-string(relative-to-dir(parse-path(dir), parse-path(pkgfile)))
      check-file(filename)
    ;Check normal folders
    do(check-dir, STANZA-PKG-DIRS)
    check-dir(system-filepath(StanzaPkgsDir))

