defpackage stz/fastio-codegen :
  import core
  import collections
  import macro-utils
  import stz/core-macros
  import stz/fastio-serializer-lang with:
    prefix(IOSpec,
           StructField,
           UnionBranch,
           CastedSpec,
           NamedSpec) => lang-

;<doc>=======================================================
;======================= Documentation ======================
;============================================================

### Datastructure Tree ###

IOSpec:
  AtomSpec
  EnumSpec
  StructSpec
  UnionSpec
  NamedSpec
  CastedSpec

;============================================================
;=======================================================<doc>

;============================================================
;======================= Code IR ============================
;============================================================

public defstruct CodeIR :
  info:FileInfo|False
  name:Symbol
  stanza-exps:Tuple
  types:Tuple<IOType>

;Represents a definition of a type.
public defstruct IOType :
  info:FileInfo|False
  type
  binder:Symbol
  writer-name:Symbol
  reader-name:Symbol
  spec:IOSpec

;Represents code for reading/writing a type.
public deftype IOSpec

;Represents code for reading/writing an atom type.
public defstruct AtomSpec <: IOSpec :
  writer
  reader

;Represents code for reading/writing an enum type.
public defstruct EnumSpec <: IOSpec :
  enum-name:Symbol

;Represents code for reading/writing a structure type.
public defstruct StructSpec <: IOSpec :
  struct-name:Symbol
  fields:Tuple<StructField>

;Represents a single field.
public defstruct StructField :
  name:Symbol
  spec:IOSpec

;Represents code for reading/writing a union type.
public defstruct UnionSpec <: IOSpec :
  branches:Tuple<UnionBranch>

;Represents one branch in a constructor.
public defstruct UnionBranch :
  type
  spec:IOSpec

;Read/write using the defined reading/writing functions.
public defstruct NamedSpec <: IOSpec :
  writer:Symbol
  reader:Symbol

;Read/write using the defined reading/writing functions
;with an additional cast.
public defstruct CastedSpec <: IOSpec :
  spec:IOSpec
  type

;Resolved writer special expression.
public defstruct ResolvedWriteSpec <: SpecialExp :
  info:FileInfo|False
  spec:IOSpec
  item

;Resolved reader special expression.
public defstruct ResolvedReadSpec <: SpecialExp :
  info:FileInfo|False
  spec:IOSpec

;============================================================
;===================== Code Generation ======================
;============================================================

;Generate the s-expressions for the given CodeIR.
;Output is not yet lowered to core forms.
public defn to-sexp (ir:CodeIR) :
  ;Overall template.
  val template = `(

    ;Define the serializer.
    info{deftype Serializer}

    ;Define the serialization functions.
    types{
      exp
    }
    
    println("Hello world")
  )

  ;Code generation environment
  val env = CodeGenEnv(name(ir))

  ;Compile the types.
  val compiled-types = for t in types(ir) map :
    [`exp => to-sexp(env, t)]

  ;Fill template with info and types.
  val filled = substitute(template, [    
    `info => wrap-info(info(ir))
    `types => nested(compiled-types)])

  ;Fill with the rest of the environment.
  fill-template(fill-env(filled, env))

;============================================================
;============ Generation of Each Constructor ================
;============================================================

;Convenience launcher that just calls the multi.
defn to-sexp (env:CodeGenEnv, t:IOType) -> Substitute :
  val template = `(
    ;Write given type to the buffer.
    info{
      defn write-xxx (serializer:Serializer, buffer:FastIOBuffer, binder:Type) -> False :
        writer-exp
    }

    ;Read given type from the buffer.
    info{
      defn read-xxx (serializer:Serializer, buffer:FastIOBuffer) -> Type :
        reader-exp
    })
      
  substitute(template, [
    `info => wrap-info(info(t))
    `buffer => buffer-name(env)
    `binder => binder(t)
    `Type => type(t)
    `write-xxx => writer-name(t)
    `read-xxx => reader-name(t)
    `writer-exp => writer-exp(env, spec(t), binder(t))
    `reader-exp => reader-exp(env, spec(t))])

;============================================================
;=========== Generation of Each Specification ===============
;============================================================

;Multis for writing/reading using a given specification.
defmulti writer-exp (env:CodeGenEnv, s:IOSpec, item) -> ?
defmulti reader-exp (env:CodeGenEnv, s:IOSpec) -> ?

;Code generation for atoms.
defmethod writer-exp (env:CodeGenEnv, s:AtomSpec, item) :
  fill-special-exp(env, writer(s))
defmethod reader-exp (env:CodeGenEnv, s:AtomSpec) :
  fill-special-exp(env, reader(s))

;Code generation for enums.
defmethod writer-exp (env:CodeGenEnv, s:EnumSpec, item) :
  false
defmethod reader-exp (env:CodeGenEnv, s:EnumSpec) :
  enum-name(s)

;Code generation for unions.
defmethod writer-exp (env:CodeGenEnv, s:UnionSpec, item) :
  ;Determine the number of branches, and the representation
  ;to use.
  val num-branches = length(branches(s))

  val representation =
    if num-branches <= 0xFF : `byte
    else if num-branches <= 0xFFFF : `short
    else : `int

  ;Determine the writer to use to write the tag.
  val write-tag = switch(representation) :
    `byte : `stz/fastio-buffer/write-byte
    `short : `stz/fastio-buffer/write-short
    `int : `stz/fastio-buffer/write-int

  ;Convert the tag into the appropriate representation.
  defn to-tag (i:Int) -> Byte|Int :
    if representation == `byte : to-byte(i)
    else : i    

  ;Binder to represent item.
  val binder = gensym(`x)

  ;Compile each of the branches.
  val compiled-branches = to-tuple $ for (branch in branches(s), index in 0 to false) seq :
    [`Type => type(branch)
     `tag => to-tag(index)
     `writer-exp => writer-exp(env, spec(branch), binder)]

  ;Match on the item, and for each branch, write a tag, and dispatch
  ;to the appropriate constructor.
  val template = `(
    match(item) :
      branches{
        (x:Type) :
          write-tag(buffer, tag)
          writer-exp
      }
      (x) : throw-error)

  substitute(template, [
    `item => item
    `write-tag => write-tag
    `branches => nested(compiled-branches)
    `x => binder])

defmethod reader-exp (env:CodeGenEnv, s:UnionSpec) :
  ;Determine the number of branches, and the representation
  ;to use.
  val num-branches = length(branches(s))

  val representation =
    if num-branches <= 0xFF : `byte
    else if num-branches <= 0xFFFF : `short
    else : `int  

  ;Convert the tag into the appropriate representation.
  defn to-tag (i:Int) -> Byte|Int :
    if representation == `byte : to-byte(i)
    else : i    

  ;Determine the reader to use to read the tag.
  val read-tag = switch(representation) :
    `byte : `stz/fastio-buffer/read-byte
    `short : `stz/fastio-buffer/read-short
    `int : `stz/fastio-buffer/read-int

  ;;Compile the tree.
  ;defn gen-code (t:RangeTree, alt:() -> ?) :
  ;  if empty?(children(t)) :
  ;  else :
  ;    val left = children(t)[0]
  ;    val right = children(t)[1]
  ;    
  ;    val end-tag = to-tag(end(t))
  ;    val template = `(
  ;      if i <= end-tag :
  ;        conseq
  ;      else :
  ;        alt
  ;    )
  ;    substitute(template, [
  ;      `i => i
  ;      `end-tag => to-tag(end(t))
  ;      `conseq => gen-code(left, gen-code{right, alt})
  ;      `alt => alt()])  

  ;Compile each of the branches.
  val compiled-branches = to-tuple $ for (branch in branches(s), index in 0 to false) seq :
    [`tag => to-tag(index)
     `reader-exp => reader-exp(env, spec(branch))]

  ;Read the tag, and for each known tag, dispatch to the
  ;appropriate reader.
  val template = `(
    switch(read-tag(buffer)) :
      branches{
        tag : reader-exp
      }
      else :
        throw-error)
  substitute(template, [
    `read-tag => read-tag
    `branches => nested(compiled-branches)])

defstruct RangeTree :
  start:Int
  end:Int
  children:Vector<RangeTree> with:
    init => Vector<RangeTree>()
with:
  printer => true

defn integer-tree (n:Int) -> RangeTree :
  defn make-tree (start:Int, end:Int) -> RangeTree :
    val n = end - start + 1
    if n < 1 :
      fatal("Empty range.")
    else if n == 1 :
      RangeTree(start, end)
    else :
      val tree = RangeTree(start, end)
      val mid = (start + end) / 2
      add(children(tree), make-tree(start, mid))
      add(children(tree), make-tree(mid + 1, end))
      tree
  make-tree(0, n - 1)

;Code generation for structures.
defmethod writer-exp (env:CodeGenEnv, s:StructSpec, item) :
  val writer-exps = to-list $ for f in fields(s) seq :
    val field-item = substitute(`(field(item)), [
                       `field => name(f)
                       `item => item])
    writer-exp(env, spec(f), field-item)
  splice(writer-exps)
    
defmethod reader-exp (env:CodeGenEnv, s:StructSpec) :
  val reader-exps = to-list $ for f in fields(s) seq :
    reader-exp(env, spec(f))
  substitute(`(Struct(fields)), [
    `Struct => struct-name(s)
    `fields => splice(reader-exps)])

;Code generation for simple NamedIOSpec.
defmethod writer-exp (env:CodeGenEnv, s:NamedSpec, item) :
  substitute(`(writer(serializer, buffer, item)), [
    `writer => writer(s)
    `item => item])

;Reader expression for a simple NamedIOSpec.
defmethod reader-exp (env:CodeGenEnv, s:NamedSpec) :
  substitute(`(reader(serializer, buffer)), [
    `reader => reader(s)])

;Code generation for CastedSpec
defmethod writer-exp (env:CodeGenEnv, spec:CastedSpec, item) :
  val template = `(
    match(item) :
      (x:Type) : writer-exp
      (x) : throw-error)
  val x = gensym(`x)
  substitute(template, [
    `item => item
    `x => x
    `Type => type(spec)
    `writer-exp => writer-exp(env, /spec(spec), x)])

defmethod reader-exp (env:CodeGenEnv, spec:CastedSpec) :
  val template = `(
    match(reader-exp) :
      (x:Type) : x
      (x) : throw-error)
  substitute(template, [
    `x => gensym(`x)
    `reader-exp => reader-exp(env, /spec(spec))
    `Type => type(spec)])

;============================================================
;============== Code Generation Environment =================
;============================================================

;Represents necessary symbols and forms for filling
;special expressions.
;- buffer-name: The name of the FastIOBuffer.
;- throw-error-form: The code to execute when we encounter an error.
defstruct CodeGenEnv :
  buffer-name: Symbol
  throw-error-form
  Serializer-name: Symbol
  serializer-name: Symbol

;Generate names given the name of the overall serializer.
defn CodeGenEnv (Serializer:Symbol) -> CodeGenEnv :
  val buffer-name = gensym(`buffer)
  val throw-error = `($do core/throw ($do stz/fastio-errors/FastIOSerializationError))
  val serializer-name = gensym(`serializer)
  CodeGenEnv(buffer-name, throw-error, Serializer, serializer-name)

;Fill the item with the generated names in CodeGenEnv.
defn fill-env (item, env:CodeGenEnv) -> Substitute :
  substitute(`x, [
    `x => item
    `buffer => deep(buffer-name(env))
    `throw-error => deep(throw-error-form(env))
    `Serializer => deep(Serializer-name(env))
    `serializer => deep(serializer-name(env))
    `FastIOBuffer => deep(`stz/fastio-buffer/FastIOBuffer)])

;============================================================
;============== Filling Special Expressions =================
;============================================================

;Fill occurrences of special expressions within the given
;environment.
defn fill-special-exp (env:CodeGenEnv, exp) -> ? :
  defn fill (exp) -> ? :
    match(exp) :
      (exp:Token) :
        sub-token-item?(exp, fill(item(exp)))
      (exp:List) :
        map(fill, exp)
      (exp:ResolvedWriteSpec) :
        val filled = fill-template(fill-env(writer-exp(env, spec(exp), item(exp)), env))
        val core-form = parse-syntax[core / #exp](filled)
        Token?(core-form, info(exp))
      (exp:ResolvedReadSpec) :
        val filled = fill-template(fill-env(reader-exp(env, spec(exp)), env))
        val core-form = parse-syntax[core / #exp](filled)
        Token?(core-form, info(exp))
      (exp:NotifyError) :
        Token?(throw-error-form(env), info(exp))
      (exp:ReifyBuffer) :
        Token?(buffer-name(env), info(exp))
      (exp:SpecialExp) :
        fatal("Unexpected special expression of type %_ during filling." % [
              object-type(exp)])
      (exp) :
        exp  
  fill(exp)

;Create a Token using the given info if one is provided.
defn Token? (x, info:FileInfo|False) -> ? :
  match(info:FileInfo) : Token(x, info)
  else : x

