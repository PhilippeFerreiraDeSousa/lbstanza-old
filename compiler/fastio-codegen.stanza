defpackage stz/fastio-codegen :
  import core
  import collections
  import macro-utils
  import stz/fastio-serializer-lang with:
    prefix(IOSpec,
           StructField,
           UnionBranch,
           CastedSpec,
           NamedSpec) => lang-

;<doc>=======================================================
;======================= Documentation ======================
;============================================================

### Datastructure Tree ###

Constructor:
  AtomConstructor
  EnumConstructor
  StructConstructor
  UnionConstructor
  SpecRW
  
SpecRW:
  NamedSpec
  CastedSpec

;============================================================
;=======================================================<doc>

;============================================================
;======================= Code IR ============================
;============================================================

public defstruct CodeIR :
  info:FileInfo|False
  name:Symbol
  stanza-exps:Tuple
  types:Tuple<IOType>

;Represents a definition of a type.
public defstruct IOType :
  info:FileInfo|False
  type
  binder:Symbol
  writer-name:Symbol
  reader-name:Symbol
  spec:IOSpec

;Represents code for reading/writing a type.
public deftype IOSpec

;Represents code for reading/writing an atom type.
public defstruct AtomSpec <: IOSpec :
  writer
  reader

;Represents code for reading/writing an enum type.
public defstruct EnumSpec <: IOSpec :
  enum-name:Symbol

;Represents code for reading/writing a structure type.
public defstruct StructSpec <: IOSpec :
  struct-name:Symbol
  fields:Tuple<StructField>

;Represents a single field.
public defstruct StructField :
  name:Symbol
  writer:IOSpec
  reader:IOSpec

;Represents code for reading/writing a union type.
public defstruct UnionSpec <: IOSpec :
  branches:Tuple<UnionBranch>

;Represents one branch in a constructor.
defstruct UnionBranch :
  type
  spec:IOSpec

;Read/write using the defined reading/writing functions.
public defstruct NamedSpec <: IOSpec :
  writer:Symbol
  reader:Symbol

;Read/write using the defined reading/writing functions
;with an additional cast.
public defstruct CastedSpec <: IOSpec :
  writer:IOSpec
  reader:IOSpec
  type

;Resolved writer special expression.
;- writer: The name of the writer function to use.
public defstruct ResolvedWriteSpec <: SpecialExp :
  info:FileInfo|False
  writer:Symbol
  item

;Resolved reader special expression
;- reader: The name of the reader function to use.
public defstruct ResolvedReadSpec <: SpecialExp :
  info:FileInfo|False
  reader:Symbol

;============================================================
;===================== Code Generation ======================
;============================================================

;Generate the s-expressions for the given CodeIR.
;Output is not yet lowered to core forms.
public defn to-sexp (ir:CodeIR) :
  ;Overall template.
  val template = `(

    ;Define the serializer.
    info{deftype Serializer}

    ;Define the serialization functions.
    types{
      exp
    }
    
    println("Hello world")
  )

  ;Code generation environment
  val env = CodeGenEnv(
    gensym(`buffer)
    `($do throw ($do FastIOSerializationError)))

  ;Compile of the types.
  val compiled-types = for t in types(ir) map :
    [`exp => to-sexp(env, t)]

  fill-template(template, [
    `buffer => deep(buffer-name(env))
    `throw-error => deep(throw-error-form(env))
    `Serializer => deep(name(ir))
    `serializer => deep(gensym(`serializer))
    `FastIOBuffer => deep(`stz/fastio-buffer/FastIOBuffer)
    `info => wrap-info(info(ir))
    `types => nested(compiled-types)])

;============================================================
;============ Generation of Each Constructor ================
;============================================================

;Convenience launcher that just calls the multi.
defn to-sexp (env:CodeGenEnv, t:IOType) -> Substitute :
  val template = `(
    ;Write given type to the buffer.
    info{
      defn write-xxx (serializer:Serializer, buffer:FastIOBuffer, binder:Type) -> False :
        writer-exp
    }

    ;Read given type from the buffer.
    info{
      defn read-xxx (serializer:Serializer, buffer:FastIOBuffer) -> Type :
        reader-exp
    })
      
  substitute(template, [
    `info => wrap-info(info(t))
    `buffer => buffer-name(env)
    `binder => binder(t)
    `Type => type(t)
    `write-xxx => writer-name(t)
    `read-xxx => reader-name(t)
    `writer-exp => writer-exp(env, spec(t), binder(t))
    `reader-exp => reader-exp(env, spec(t))])

;============================================================
;=========== Generation of Each Specification ===============
;============================================================

;Multis for writing/reading using a given specification.
defmulti writer-exp (env:CodeGenEnv, s:IOSpec, item) -> ?
defmulti reader-exp (env:CodeGenEnv, s:IOSpec) -> ?

;Code generation for atoms.
defmethod writer-exp (env:CodeGenEnv, s:AtomSpec, item) :
  fill-special-exp(env, writer(s))
defmethod reader-exp (env:CodeGenEnv, s:AtomSpec) :
  fill-special-exp(env, reader(s))

;Code generation for enums.
defmethod writer-exp (env:CodeGenEnv, s:EnumSpec, item) :
  false
defmethod reader-exp (env:CodeGenEnv, s:EnumSpec) :
  enum-name(s)

;Code generation for unions.
defmethod writer-exp (env:CodeGenEnv, s:UnionSpec, item) :
  ;Determine the number of branches, and the representation
  ;to use.
  val num-branches = length(branches(s))

  val representation =
    if num-branches <= 0xFF : `byte
    else if num-branches <= 0xFFFF : `short
    else : `int

  ;Determine the writer to use to write the tag.
  val write-tag = switch(representation) :
    `byte : `stz/fastio-buffer/write-byte
    `short : `stz/fastio-buffer/write-short
    `int : `stz/fastio-buffer/write-int

  ;Convert the tag into the appropriate representation.
  defn to-tag (i:Int) -> Byte|Int :
    if representation == `byte : to-byte(i)
    else : i    

  ;Binder to represent item.
  val binder = gensym(`x)

  ;Compile each of the branches.
  val compiled-branches = to-tuple $ for (branch in branches(s), index in 0 to false) seq :
    [`Type => type(branch)
     `tag => to-tag(index)
     `writer-exp => writer-exp(env, spec(branch), binder)]

  ;Match on the item, and for each branch, write a tag, and dispatch
  ;to the appropriate constructor.
  val template = `(
    match(item) :
      branches{
        (x:Type) :
          write-tag(buffer, tag)
          writer-exp
      }
      (x) : throw-error)

  substitute(template, [
    `item => item
    `write-tag => write-tag
    `branches => nested(compiled-branches)
    `x => binder])

defmethod reader-exp (env:CodeGenEnv, s:UnionSpec) :
  ;Determine the number of branches, and the representation
  ;to use.
  val num-branches = length(branches(s))

  val representation =
    if num-branches <= 0xFF : `byte
    else if num-branches <= 0xFFFF : `short
    else : `int  

  ;Convert the tag into the appropriate representation.
  defn to-tag (i:Int) -> Byte|Int :
    if representation == `byte : to-byte(i)
    else : i    

  ;Determine the reader to use to read the tag.
  val read-tag = switch(representation) :
    `byte : `stz/fastio-buffer/read-byte
    `short : `stz/fastio-buffer/read-short
    `int : `stz/fastio-buffer/read-int

  ;Compile each of the branches.
  val compiled-branches = to-tuple $ for (branch in branches(s), index in 0 to false) seq :
    [`tag => to-tag(index)
     `reader-exp => reader-exp(env, spec(branch))]

  ;Read the tag, and for each known tag, dispatch to the
  ;appropriate reader.
  val template = `(
    switch(read-tag(buffer)) :
      branches{
        tag : reader-exp
      }
      else :
        throw-error)
  substitute(template, [
    `read-tag => read-tag
    `branches => nested(compiled-branches)])

;Code generation for structures.
defmethod writer-exp (env:CodeGenEnv, s:StructSpec, item) :
  val writer-exps = to-list $ for f in fields(s) seq :
    val field-item = substitute(`(field(item)), [
                       `field => name(f)
                       `item => item])
    writer-exp(env, writer(f), field-item)
  splice(writer-exps)
    
defmethod reader-exp (env:CodeGenEnv, s:StructSpec) :
  val reader-exps = to-list $ for f in fields(s) seq :
    reader-exp(env, reader(f))
  substitute(`(Struct(fields)), [
    `Struct => struct-name(s)
    `fields => splice(reader-exps)])

;Code generation for simple NamedIOSpec.
defmethod writer-exp (env:CodeGenEnv, s:NamedSpec, item) :
  substitute(`(writer(serializer, buffer, item)), [
    `writer => writer(s)
    `item => item])

;Reader expression for a simple NamedIOSpec.
defmethod reader-exp (env:CodeGenEnv, s:NamedSpec) :
  substitute(`(reader(serializer, buffer)), [
    `reader => reader(s)])

;Code generation for CastedSpec
defmethod writer-exp (env:CodeGenEnv, spec:CastedSpec, item) :
  val template = `(
    match(item) :
      (x:Type) : writer-exp
      (x) : throw-error)
  val x = gensym(`x)
  substitute(template, [
    `item => item
    `x => x
    `Type => type(spec)
    `writer-exp => writer-exp(env, writer(spec), x)])

defmethod reader-exp (env:CodeGenEnv, spec:CastedSpec) :
  val template = `(
    match(reader-exp) :
      (x:Type) : x
      (x) : throw-error)
  substitute(template, [
    `x => gensym(`x)
    `reader-exp => reader-exp(env, reader(spec))
    `Type => type(spec)])

;============================================================
;============== Code Generation Environment =================
;============================================================

;Represents necessary symbols and forms for filling
;special expressions.
;- buffer-name: The name of the FastIOBuffer.
;- throw-error-form: The code to execute when we encounter an error.
defstruct CodeGenEnv :
  buffer-name: Symbol
  throw-error-form

;============================================================
;============== Filling Special Expressions =================
;============================================================

;Fill occurrences of special expressions within the given
;environment.
defn fill-special-exp (env:CodeGenEnv, exp) -> ? :
  defn fill (exp) -> ? :
    match(exp) :
      (exp:Token) :
        sub-token-item?(exp, fill(item(exp)))
      (exp:List) :
        map(fill, exp)
      (exp:ResolvedWriteSpec) :
        val form = qquote($do ~(writer(exp)) ~(buffer-name(env)) ~(item(exp)))
        Token?(form, info(exp))
      (exp:ResolvedReadSpec) :
        val form = qquote($do ~(reader(exp)) ~(buffer-name(env)))
        Token?(form, info(exp))
      (exp:NotifyError) :
        Token?(throw-error-form(env), info(exp))
      (exp:ReifyBuffer) :
        Token?(buffer-name(env), info(exp))
      (exp:SpecialExp) :
        fatal("Unexpected special expression of type %_ during filling." % [
              object-type(exp)])
      (exp) :
        exp  
  fill(exp)

;Create a Token using the given info if one is provided.
defn Token? (x, info:FileInfo|False) -> ? :
  match(info:FileInfo) : Token(x, info)
  else : x

