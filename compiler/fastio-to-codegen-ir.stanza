defpackage stz/fastio-to-codegen-ir :
  import core
  import collections
  import stz/fastio-serializer-lang
  import stz/fastio-codegen with:
    prefix(IOSpec,
           CastedSpec,
           NamedSpec,
           UnionBranch) => Code

;Convert the pre-transformed input IR to CodeGen IR.
public defn to-codegen-ir (s:DefSerializer) -> CodeIR :
  ;Accumulate Stanza expressions here.
  val stanza-exps = Vector<?>()
  
  ;Accumulate converted IOType here.
  val iotypes = Vector<IOType>()

  ;Convert all TopExp to IOType.
  val names = generate-writer-reader-names(s)
  for e in exps(s) do :
    match(e) :
      (e:DefAtom|DefType|DefUnion) : add(iotypes, to-type(e, names))
      (e:StanzaExp) : add(stanza-exps, Token?(exp(e), info(e)))
      
  ;Create final CodeIR.
  CodeIR(info(s),
         name(s),
         to-tuple(stanza-exps),
         to-tuple(iotypes))

;Convert the input TopExp into the CodeGen IOType.
public defn to-type (e:TopExp,
                     names:HashTable<Symbol,[Symbol,Symbol]>) -> IOType :
  match(e) :
    (e:DefAtom) :
      val writer-body = to-code-body(writer(e), names)
      val reader-body = to-code-body(reader(e), names)
      val spec = AtomSpec(writer-body, reader-body)
      val [writer-name, reader-name] = names[name(e)]
      IOType(info(e), type(e), binder(e), writer-name, reader-name, spec)
    (e:DefType) :
      val spec = to-spec(constructor(e), type(e), names)
      val [writer-name, reader-name] = names[name(e)]
      IOType(info(e), type(e), gensym(`x), writer-name, reader-name, spec)
    (e:DefUnion) :
      val branches = for b in branches(e) map :
        CodeUnionBranch(type(b), to-spec(constructor(b), type(b), names))
      val spec = UnionSpec(branches)        
      val [writer-name, reader-name] = names[name(e)]
      IOType(info(e), type(e), gensym(`x), writer-name, reader-name, spec)
    (e) :
      fatal("Unexpected expression of type %_." % [object-type(e)])

;Convert the given constructor into an IOSpec.
defn to-spec (c:Constructor,
              type,
              names:HashTable<Symbol,[Symbol,Symbol]>) -> CodeIOSpec :
  match(c) :
    (c:EnumConstructor) :
      ;Assume to be valid Symbol because of validation checks.
      val enum-name = unwrap-token(type) as Symbol
      EnumSpec(enum-name)
    (c:StructConstructor) :
      ;Assume to be valid Symbol because of validation checks.
      val struct-name = unwrap-token(type) as Symbol
      val struct-fields = for f in args(c) map :
        StructField(name(f), to-code-spec(spec(f), names))      
      StructSpec(struct-name, struct-fields)
    (c:IOSpec) :
      to-code-spec(c, names)

;Convert the given spec into a Codegen IOSpec.
defn to-code-spec (s:IOSpec,
                   names:HashTable<Symbol,[Symbol,Symbol]>) -> CodeIOSpec :
  match(s) :
    (s:NamedSpec) :
      val [writer-name, reader-name] = names[name(s)]
      CodeNamedSpec(writer-name, reader-name)
    (s:CastedSpec) :
      val spec = to-code-spec(spec(s), names)
      CodeCastedSpec(spec, type(s))
    (s:CombinatorSpec) :
      fatal("Unexpected CombinatorSpec.")

;Convert the given body into a Codegen body.
defn to-code-body (form,
                   names:HashTable<Symbol,[Symbol,Symbol]>) -> ? :
  match(form) :
    (form:Token) :
      Token(to-code-body(item(form), names), info(form))
    (form:List) :
      map(to-code-body{_, names}, form)
    (form:WriteSpec) :
      val new-item = to-code-body(item(form), names)
      val new-spec = to-code-spec(spec(form), names)
      ResolvedWriteSpec(info(form), new-spec, new-item)
    (form:ReadSpec) :
      val new-spec = to-code-spec(spec(form), names)
      ResolvedReadSpec(info(form), new-spec)      
    (form) :
      form

;Generate the reader/writer names for the definitions in the given
;serializer.
defn generate-writer-reader-names (s:DefSerializer)
                                -> HashTable<Symbol,[Symbol,Symbol]> :
  ;Compute the set of existing names.
  val name-set = to-hashset<Symbol> $
    for e in exps(s) seq? :
      match(e) :
        (e:DefAtom|DefType|DefUnion) : One(name(e))
        (e) : None()

  ;Ensure not a name. If it is already a name, then
  ;call gensym on it.
  defn ensure-non-name (x:Symbol) -> Symbol :
    if name-set[x] : gensym(x)
    else : x

  ;Add the given prefix to a symbol.
  defn prefix (pre:String, s:Symbol) -> Symbol :
    match(s) :
      (s:StringSymbol) :
        to-symbol(append(pre, name(s)))
      (s:GenSymbol) :
        gensym(append(pre, name(s)))

  ;Generate new names for all existing names.
  to-hashtable<Symbol,[Symbol,Symbol]> $
    for entry in name-set seq :
      val new-names = [
        ensure-non-name(prefix("write-", entry))
        ensure-non-name(prefix("read-", entry))]
      entry => new-names

;Helper: Create a Token using the given info if one is provided.
defn Token? (x, info:FileInfo|False) -> ? :
  match(info:FileInfo) : Token(unwrap-token(x), info)
  else : x