defpackage core/stack-trace :
  import core
  import collections
  
;============================================================
;================ High Level Representation =================
;============================================================

;Representation of a packed StackTrace
public lostanza deftype StackTrace <: Unique :
  length:long
  traces:ptr<PackedStackTrace> ...

;Represents a single item in the stack trace
public defstruct StackTraceEntry :
  package:Symbol
  signature:String|False
  info:FileInfo|False

;------------------------------------------------------------
;------------------- Printing -------------------------------
;------------------------------------------------------------

public defn print-trace (o:OutputStream, trace:StackTrace) :
  for i in 0 to num-traces(trace) do :
    print(o, '\n') when i > 0
    print-trace(o, trace[i])

public defn print-trace (o:OutputStream, e:StackTraceEntry) :
  val sig-str = "" when signature(e) is False else "/%_" % [signature(e)]
  print(o, "  in %_%_" % [package(e), sig-str])
  match(info(e):FileInfo) :
    lnprint(o, "    at %_" % [info(e)])

;------------------------------------------------------------
;---------------------- API Functions -----------------------
;------------------------------------------------------------

defmethod print (o:OutputStream, e:StackTraceEntry) :
  val sig-str = "" when signature(e) is False else "/%_" % [signature(e)]
  val info-str = "" when info(e) is False else " at %_" % [info(e)]
  print(o, "StackTraceEntry(%_%_%_)" % [package(e), sig-str, info-str])

public lostanza defn num-traces (trace:ref<StackTrace>) -> ref<Int> :
  var num-traces:int = 0
  val len = trace.length
  for (var i:int = 0, i < len, i = i + 1) :
    num-traces = num-traces + trace.traces[i].num-entries
  return new Int{num-traces}

public lostanza defn get (trace:ref<StackTrace>, i:ref<Int>) -> ref<StackTraceEntry> :
  labels :
    begin: goto loop(0, i.value)
    loop (trace-index:int, i:int) :
      val trace = trace.traces[trace-index]
      if i >= trace.num-entries : goto loop(trace-index + 1, i - trace.num-entries)
      else : return entry(trace, i)
      
;------------------------------------------------------------
;---------------------- Constructor -------------------------
;------------------------------------------------------------
public lostanza defn StackTrace (len:int, datas:ptr<ptr<PackedStackTrace>>) -> ref<StackTrace> :
  val trace = new StackTrace{len}
  call-c clib/memcpy(addr!(trace.traces), datas, len * sizeof(ptr<?>))
  for (var i:int = 0, i < len, i = i + 1) :
    add-finalizer(new TraceFinalizer{datas[i]}, trace)
  return trace

;------------------------------------------------------------
;---------------------- Finalization ------------------------
;------------------------------------------------------------
lostanza deftype TraceFinalizer <: Finalizer :
  trace:ptr<PackedStackTrace>
  
lostanza defmethod run (f:ref<TraceFinalizer>) -> ref<False> :
  call-c clib/printf("Free memory for trace %p\n", f.trace)
  call-c clib/free(f.trace)
  return false

;============================================================
;=================== Packed Representation ==================
;============================================================

;Packed representation of a stack trace.
public lostanza deftype PackedStackTrace :
  num-entries:int
  num-records:int
  num-char-words:int
  data:byte ...

;Packed representation of a single stack trace record.
lostanza deftype PackedStackTraceRecord :
  package:int
  signature:int
  file:int
  line:int
  column:int

;------------------------------------------------------------
;--------------------- Accessors ----------------------------
;------------------------------------------------------------

;Return the number of bytes in the trace.
lostanza defn num-bytes (trace:ptr<PackedStackTrace>) -> int :
  val n = trace.num-entries * sizeof(int) +
          trace.num-records * sizeof(PackedStackTraceRecord) +
          trace.num-char-words * sizeof(long)
  return n as int

;Return the address at which the entries start.
lostanza defn entries (trace:ptr<PackedStackTrace>) -> ptr<int> :
  return addr(trace.data) as ptr<int>

;Return the address at which the records start.
lostanza defn records (trace:ptr<PackedStackTrace>) -> ptr<PackedStackTraceRecord> :
  return addr(entries(trace)[trace.num-entries]) as ptr<PackedStackTraceRecord>

;Return the address at which the characters start.
lostanza defn char-words (trace:ptr<PackedStackTrace>) -> ptr<long> :
  return addr(records(trace)[trace.num-records]) as ptr<long>

;------------------------------------------------------------
;------------------------ Unpacking -------------------------
;------------------------------------------------------------

;Return the string at index i. Returns false if i is negative.
lostanza defn unpack-string (trace:ptr<PackedStackTrace>, i:int) -> ref<String|False> :
  if i < 0 : return false
  val chars = addr(char-words(trace)[i]) as ptr<byte>
  return String(chars)

;Unpack the given record at the given index.
lostanza defn record (trace:ptr<PackedStackTrace>, i:int) -> ref<StackTraceEntry> :
  ;Retrieve the i'th record.
  val r = records(trace)[i]
  val package = unpack-string(trace, r.package) as ref<String>
  val signature = unpack-string(trace, r.signature)
  val file = unpack-string(trace, r.file)
  var info:ref<FileInfo|False> = false
  if file != false :
    info = FileInfo(file as ref<String>,
                    new Int{r.line}, new Int{r.column})
  return StackTraceEntry(to-symbol(package), signature, info)

;Unpack the given entry at the given index.
lostanza defn entry (trace:ptr<PackedStackTrace>, i:int) -> ref<StackTraceEntry> :
  ;Get the index of the record that forms this entry.
  val record-index = entries(trace)[i]
  return record(trace, record-index)

;============================================================
;============= Stack Trace Builder Algorithm ================
;============================================================

;------------------------------------------------------------
;--------------------- Public API ---------------------------
;------------------------------------------------------------

public lostanza deftype StackTraceRecord :
  package:ptr<byte>
  signature:ptr<byte>
  file:ptr<byte>
  line:int
  column:int

;Add the given record as an entry in the stack trace.
public lostanza defn add-entry (b:ref<StackTraceBuilder>,
                                e:ptr<StackTraceRecord>) -> ref<False> :
  add-entry(b, add-record?(b, e))
  return false
  
;Pack into a stable array.
public lostanza defn pack (b:ref<StackTraceBuilder>) -> ptr<PackedStackTrace> :
  val buffer = pack-buffer(b)  
  val len = length(buffer).value
  val mem:ptr<PackedStackTrace> = call-c clib/malloc(len)
  call-c clib/memcpy(mem, data(buffer), len)
  return mem

;------------------------------------------------------------
;-------------------- Implementation ------------------------
;------------------------------------------------------------

;Add the given StackTraceRecord to the StackTraceBuilder and return the index at which
;it is written. If this address has been added before then return the previous index.
lostanza defn add-record? (b:ref<StackTraceBuilder>, e:ptr<StackTraceRecord>) -> ref<Int> :
  val index = record-index?(b, new Long{e as long})
  if index == false :
    return add-record(b,
                      new Long{e as long},
                      add-string?(b, e.package),
                      add-string?(b, e.signature),
                      add-string?(b, e.file),
                      new Int{e.line}
                      new Int{e.column})
  else :
    return index as ref<Int>

;Add the given string to the StackTraceBuilder and return the index at which
;it is written. If that address has been added before then return the previous index.
;Returns -1 if the given address is null.
lostanza defn add-string? (b:ref<StackTraceBuilder>, s:ptr<byte>) -> ref<Int> :
  if s == null : return new Int{-1}
  val index = string-index?(b, new Long{s as long})
  if index == false : return add-string(b, new Long{s as long}, String(s))
  else : return index as ref<Int>

;============================================================
;============= Stack Trace Builder Utility ==================
;============================================================

;Builder utility for constructing packed stack traces.
public deftype StackTraceBuilder

;------------------------------------------------------------
;--------------------- Internal API -------------------------
;------------------------------------------------------------
defmulti add-entry (b:StackTraceBuilder, entry:Int) -> False
defmulti record-index? (b:StackTraceBuilder, record:Long) -> Int|False
defmulti add-record (b:StackTraceBuilder, record:Long,
                     package:Int, signature:Int, file:Int, line:Int, column:Int) -> Int
defmulti string-index? (b:StackTraceBuilder, str:Long) -> Int|False
defmulti add-string (b:StackTraceBuilder, address:Long, str:String) -> Int
defmulti pack-buffer (b:StackTraceBuilder) -> ByteBuffer

;------------------------------------------------------------
;--------------------- Implementation -----------------------
;------------------------------------------------------------

public defn StackTraceBuilder () -> StackTraceBuilder :
  val entries = Vector<Int>()
  val record-buffer = ByteBuffer()
  val string-buffer = ByteBuffer()
  val record-table = HashTable<Long,Int>()
  val string-table = HashTable<Long,Int>()
  new StackTraceBuilder :
    defmethod add-entry (this, entry:Int) :
      add(entries, entry)
    defmethod record-index? (this, record:Long) :
      get?(record-table, record)
    defmethod add-record (this, record:Long,
                          package:Int, signature:Int, file:Int, line:Int, column:Int) :
      val index = length(record-table)
      record-table[record] = index
      put(record-buffer, package)
      put(record-buffer, signature)
      put(record-buffer, file)
      put(record-buffer, line)
      put(record-buffer, column)
      index
    defmethod string-index? (this, str:Long) :
      get?(string-table, str)
    defmethod add-string (this, address:Long, str:String) :
      ;Get the index
      val index = length(string-buffer) >> 3
      string-table[address] = index
      ;Put the characters and 0 ending.
      print(string-buffer, str)
      put(string-buffer, 0Y)
      ;Pad up to 8-bytes
      val remaining = (8 - (length(string-buffer) & 7)) & 7
      for i in 0 to remaining do : put(string-buffer, 0Y)
      ;Return the index
      index
    defmethod pack-buffer (this) :
      val buffer = ByteBuffer()
      put(buffer, length(entries))
      put(buffer, length(record-table))
      put(buffer, length(string-buffer) >> 3)
      do(put{buffer, _}, entries)
      do(put{buffer, _}, record-buffer)
      do(put{buffer, _}, string-buffer)
      buffer