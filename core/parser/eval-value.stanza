defpackage parser/eval-value :
  import core
  import collections
  import parser/context
  import parser/engine-value-stack
  import parser/errors

;============================================================
;=============== Evaluating Parsed Results ==================
;============================================================

;Given a result object, evaluate the appropriate callbacks to
;compute the final value.
;Throws an exception if the provided action throws an exception.
public defn evaluate-result (actions:Tuple<(Context -> ?)>,
                             overlay-actions:Tuple<(Context -> ?)>,
                             result) -> ? :
  match(result) :
    ;Create a context, and execute the appropriate action
    ;given the context.
    (result:ActionResult) :
      val active-actions = overlay-actions when overlay?(result)
                      else actions
      val action = active-actions[action-index(result)]
      action $ 
        if lazy?(result) : make-lazy-context(actions, overlay-actions, result)
        else : make-eager-context(actions, overlay-actions, result)

    ;Evaluate each result, and return result as a list.
    (result:ListResult) :
      val accum = Vector<?>()
      for v in results(result) do :
        add(accum, evaluate-result(actions, overlay-actions, v))
      to-list(accum)

    ;Should not appear in a successful parse.
    (result:FailedResult) :
      fatal("FailResult cannot be evaluated.")

    ;If it is not one of the unevaluated results, then
    ;it is just the value as is.
    (result) :
      result

;============================================================
;================= Evaluating Guards ========================
;============================================================

;Evaluate the given guard action.
public defn evaluate-guard (action:Context -> ?, value:ActionResult) -> True|False :
  action(make-noeval-context(value))

;============================================================
;============== Implementation of Contexts ==================
;============================================================

;Create an execution context for evaluating the given result.
;The context is lazy in the sense that the user controls when
;subvalues are evaluated. If they are never called, then they are never
;evaluated.
;
;Note that lazy contexts are used for evaluating single-binder
;actions as well. If there is only a single binder then the
;error-collecting behaviour of eager contexts are unnecessary.

defn make-lazy-context (actions:Tuple<(Context -> ?)>,
                        overlay-actions:Tuple<(Context -> ?)>,
                        value:ActionResult) -> Context :
  new Context :
    defmethod get (this, i:Int) :
      evaluate-result(actions, overlay-actions, args(value)[i])
    defmethod get-all (this) :
      fatal("Lazy contexts are designed to provide its bindings one at a time.")
    defmethod info (this) :
      info(value)

;Create an execution context for evaluating the given result.
;The context is eager in the sense that the system evaluates
;all the bindings before beginning execution of the action body.
;If any binding throws an exception, then the body is never executed.
defn make-eager-context (actions:Tuple<(Context -> ?)>,
                         overlay-actions:Tuple<(Context -> ?)>,
                         value:ActionResult) -> Context :
  new Context :
    defmethod get-all (this) :
      if any?({_ is UnevaluatedResult}, args(value)) :
        val accum = Vector<?>()
        val errors = Vector<Exception>()
        for arg in args(value) do :
          try : add(accum, evaluate-result(actions, overlay-actions, arg))
          catch (e:ParseErrors) : add-all(errors, /errors(e))
          catch (e:Exception) : add(errors, e)
        if empty?(errors) : to-tuple(accum)
        else : throw(ParseErrors(to-tuple(errors)))          
      else :
        args(value)
    defmethod get (this, i:Int) :
      fatal("Eager contexts are designed to provide all its bindings at once.")
    defmethod info (this) :
      info(value)

;Create an execution result for evaluating guards.
;The context is a noeval context in the sense that retrievals of
;UnevaluatedResult is forbidden.
defn make-noeval-context (value:ActionResult) -> Context :
  new Context :
    defmethod get (this, i:Int) :
      match(args(value)[i]) :
        (r:UnevaluatedResult) : fatal("Cannot retrieve unevaluated result from noeval context.")
        (r) : r
    defmethod get-all (this) :
      fatal("Noeval contexts are designed to provide its bindings one at a time.")
    defmethod info (this) :
      fatal("Noeval contexts have no file information.")