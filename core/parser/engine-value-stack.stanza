defpackage parser/engine-value-stack :
  import core
  import collections

;============================================================
;==================== Stack Markers =========================
;============================================================

;A marker is pushed onto the value stack when collecting the
;binders necessary for evaluating actions.
public deftype ValueMarker

;Represents the start of the bound values necessary for evaluating
;an action.
;- info: The file position at the time the action was started.
public defstruct ActionMarker <: ValueMarker :
  info:FileInfo|False
with: (printer => true)

;Represents the end of the bound values for evaluating an action.
;- overlay?: True if it is an overlay action.
;- start-index: The index on the value-stack of the corresponding
;  ActionMarker. This allows us to traverse the value-stack in reverse
;  order.
;- encountered-failure?: True if a [Fail] was encountered
;  during evaluation of the results, and the binders were not
;  computed successfully.
public defstruct ActionEndMarker <: ValueMarker :
  overlay?:True|False
  start-index:Int
  lazy?:True|False
  action-index:Int
  encountered-failure?:True|False
with: (printer => true)

;Represents the start of a list.
;- arity: The number of binders in the list pattern.
public defstruct ListMarker <: ValueMarker :
  arity:Int
with: (printer => true)

;Represents the end of a list.
public defstruct ListEndMarker <: ValueMarker
with: (printer => true)

;============================================================
;================ Representation of Values ==================
;============================================================

;Simple binders are represented directly on the value stack.
;Values that need to be computed are represented as UnevaluatedResult
;objects.
public deftype UnevaluatedResult

;Represents an unevaluated result from an Action.
;- overlay?: True if the action is an overlay action.
;- action-index: The index of the action.
;- lazy?: True if the action evaluates its binders lazily.
;- info: The file position at the time the action was started.
;- args: The values of the bound arguments.
public defstruct ActionResult <: UnevaluatedResult :
  overlay?:True|False  
  action-index:Int
  lazy?:True|False
  info:FileInfo|False
  args:Tuple
with:
  printer => true

;Represents an unevaluated list of results.
public defstruct ListResult <: UnevaluatedResult :
  results:Vector

;Represents an action result for which parsing
;of one of the subbinders has already failed. Does not
;appear in a successful parse.
public defstruct FailedResult <: UnevaluatedResult

;============================================================
;==================== Parsing API ===========================
;============================================================

;Parse the first value on the value stack.
public defn parse-first-value (values:Vector) -> ? :
  parse-value(values, 0)

;Parse the last value on the value stack.
public defn parse-last-value (values:Vector) -> ? :
  match(peek(values)) :
    (v:ActionEndMarker) :
      if encountered-failure?(v) : FailedResult()
      else : parse-value(values, start-index(v))
    (v:ListEndMarker) :
      fatal("Unexpected list end marker.")
    (v) :
      v

;============================================================
;================= Parsing Algorithm ========================
;============================================================

;Parse the value at the given index.
defn parse-value (values:Vector, start:Int) -> ? :

  ;Parse a value starting from 'index' and push its
  ;result into 'accum'.
  ;Return the index after the parsed value.
  defn store-in-accum (accum:Vector, index:Int) -> Int :
    match(values[index]) :
      ;Case: It's an action value.
      (v:ActionMarker) :
        val args = Vector<?>()
        let loop (index:Int = index + 1) :
          match(values[index]) :
            (end:ActionEndMarker) :
              if encountered-failure?(end) :
                add(accum, FailedResult())
              else :
                add(accum, ActionResult(overlay?(end),
                                        action-index(end),
                                        lazy?(end),
                                        info(v),
                                        to-tuple(args)))
              index + 1
            (v) :
              loop(store-in-accum(args, index))

      ;Case: It's a list value.
      (v:ListMarker) :
        ;If arity is 1, then parse it specially.
        ;A single vector is enough.
        if arity(v) == 1 :
          val args = Vector<?>()
          let loop (index:Int = index + 1) :
            if values[index] is ListEndMarker :
              add(accum, ListResult(args))
              index + 1
            else :
              loop(store-in-accum(args, index))
        ;Otherwise, we need to create N vectors,
        ;and add the items to each vector in turn.
        else :
          val args = to-tuple $
            for i in 0 to arity(v) seq : Vector<?>()
          var index:Int = index + 1
          let loop () :
            if values[index] is ListEndMarker :
              add-all(accum, seq(ListResult, args))
              index + 1
            else :
              for i in 0 to arity(v) do :
                index = store-in-accum(args[i], index)
              loop()
              
      ;Case: Unexpected marker.
      (v:ListEndMarker) :
        fatal("Unexpected list end marker.")
        
      ;Case: Simple binder.
      (v) :
        add(accum, v)
        index + 1

  ;Launch!
  clear(BUFFER)
  store-in-accum(BUFFER, start)
  BUFFER[0]

;Single element buffer for storing result of parse-value.
val BUFFER = Vector<?>(1)